<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.7" xml:lang="en-US">
  <compounddef id="namespacefutures" kind="namespace" language="C++">
    <compoundname>futures</compoundname>
    <innerclass refid="classfutures_1_1all__of__functor" prot="public">futures::all_of_functor</innerclass>
    <innerclass refid="structfutures_1_1always__deferred__opt" prot="public">futures::always_deferred_opt</innerclass>
    <innerclass refid="structfutures_1_1always__detached__opt" prot="public">futures::always_detached_opt</innerclass>
    <innerclass refid="classfutures_1_1any__of__functor" prot="public">futures::any_of_functor</innerclass>
    <innerclass refid="classfutures_1_1basic__future" prot="public">futures::basic_future</innerclass>
    <innerclass refid="classfutures_1_1binary__invoke__algorithm__functor" prot="public">futures::binary_invoke_algorithm_functor</innerclass>
    <innerclass refid="classfutures_1_1broken__promise" prot="public">futures::broken_promise</innerclass>
    <innerclass refid="structfutures_1_1compare__three__way" prot="public">futures::compare_three_way</innerclass>
    <innerclass refid="structfutures_1_1continuable__opt" prot="public">futures::continuable_opt</innerclass>
    <innerclass refid="classfutures_1_1count__functor" prot="public">futures::count_functor</innerclass>
    <innerclass refid="classfutures_1_1count__if__functor" prot="public">futures::count_if_functor</innerclass>
    <innerclass refid="structfutures_1_1deferred__function__opt" prot="public">futures::deferred_function_opt</innerclass>
    <innerclass refid="structfutures_1_1equal__to" prot="public">futures::equal_to</innerclass>
    <innerclass refid="classfutures_1_1error" prot="public">futures::error</innerclass>
    <innerclass refid="structfutures_1_1executor__opt" prot="public">futures::executor_opt</innerclass>
    <innerclass refid="classfutures_1_1find__functor" prot="public">futures::find_functor</innerclass>
    <innerclass refid="classfutures_1_1find__if__functor" prot="public">futures::find_if_functor</innerclass>
    <innerclass refid="classfutures_1_1find__if__not__functor" prot="public">futures::find_if_not_functor</innerclass>
    <innerclass refid="classfutures_1_1for__each__functor" prot="public">futures::for_each_functor</innerclass>
    <innerclass refid="classfutures_1_1future__already__retrieved" prot="public">futures::future_already_retrieved</innerclass>
    <innerclass refid="classfutures_1_1future__deferred" prot="public">futures::future_deferred</innerclass>
    <innerclass refid="classfutures_1_1future__uninitialized" prot="public">futures::future_uninitialized</innerclass>
    <innerclass refid="structfutures_1_1greater" prot="public">futures::greater</innerclass>
    <innerclass refid="structfutures_1_1greater__equal" prot="public">futures::greater_equal</innerclass>
    <innerclass refid="classfutures_1_1halve__partitioner" prot="public">futures::halve_partitioner</innerclass>
    <innerclass refid="structfutures_1_1has__executor" prot="public">futures::has_executor</innerclass>
    <innerclass refid="structfutures_1_1has__ready__notifier" prot="public">futures::has_ready_notifier</innerclass>
    <innerclass refid="classfutures_1_1inline__executor" prot="public">futures::inline_executor</innerclass>
    <innerclass refid="structfutures_1_1is__always__deferred" prot="public">futures::is_always_deferred</innerclass>
    <innerclass refid="structfutures_1_1is__continuable" prot="public">futures::is_continuable</innerclass>
    <innerclass refid="structfutures_1_1is__execution__policy" prot="public">futures::is_execution_policy</innerclass>
    <innerclass refid="structfutures_1_1is__future__like" prot="public">futures::is_future_like</innerclass>
    <innerclass refid="structfutures_1_1is__shared__future" prot="public">futures::is_shared_future</innerclass>
    <innerclass refid="structfutures_1_1less" prot="public">futures::less</innerclass>
    <innerclass refid="structfutures_1_1less__equal" prot="public">futures::less_equal</innerclass>
    <innerclass refid="classfutures_1_1new__thread__executor" prot="public">futures::new_thread_executor</innerclass>
    <innerclass refid="classfutures_1_1no__state" prot="public">futures::no_state</innerclass>
    <innerclass refid="classfutures_1_1none__of__functor" prot="public">futures::none_of_functor</innerclass>
    <innerclass refid="structfutures_1_1nostopstate__t" prot="public">futures::nostopstate_t</innerclass>
    <innerclass refid="structfutures_1_1not__equal__to" prot="public">futures::not_equal_to</innerclass>
    <innerclass refid="classfutures_1_1packaged__task_3_01R_07Args_8_8_8_08_00_01Options_01_4" prot="public">futures::packaged_task&lt; R(Args...), Options &gt;</innerclass>
    <innerclass refid="classfutures_1_1packaged__task__uninitialized" prot="public">futures::packaged_task_uninitialized</innerclass>
    <innerclass refid="classfutures_1_1promise" prot="public">futures::promise</innerclass>
    <innerclass refid="classfutures_1_1promise__already__satisfied" prot="public">futures::promise_already_satisfied</innerclass>
    <innerclass refid="classfutures_1_1promise__base" prot="public">futures::promise_base</innerclass>
    <innerclass refid="classfutures_1_1promise__uninitialized" prot="public">futures::promise_uninitialized</innerclass>
    <innerclass refid="classfutures_1_1reduce__functor" prot="public">futures::reduce_functor</innerclass>
    <innerclass refid="structfutures_1_1shared__opt" prot="public">futures::shared_opt</innerclass>
    <innerclass refid="classfutures_1_1stop__source" prot="public">futures::stop_source</innerclass>
    <innerclass refid="classfutures_1_1stop__token" prot="public">futures::stop_token</innerclass>
    <innerclass refid="structfutures_1_1stoppable__opt" prot="public">futures::stoppable_opt</innerclass>
    <innerclass refid="classfutures_1_1thread__partitioner" prot="public">futures::thread_partitioner</innerclass>
    <innerclass refid="classfutures_1_1thread__pool" prot="public">futures::thread_pool</innerclass>
    <innerclass refid="classfutures_1_1unary__invoke__algorithm__functor" prot="public">futures::unary_invoke_algorithm_functor</innerclass>
    <innerclass refid="classfutures_1_1value__cmp__algorithm__functor" prot="public">futures::value_cmp_algorithm_functor</innerclass>
    <innerclass refid="classfutures_1_1when__all__future" prot="public">futures::when_all_future</innerclass>
    <innerclass refid="classfutures_1_1when__any__future" prot="public">futures::when_any_future</innerclass>
    <innerclass refid="structfutures_1_1when__any__result" prot="public">futures::when_any_result</innerclass>
    <innerconcept refid="conceptfutures_1_1partitioner__for">futures::partitioner_for</innerconcept>
    <innerconcept refid="conceptfutures_1_1execution__policy">futures::execution_policy</innerconcept>
    <innerconcept refid="conceptfutures_1_1execution__context__for">futures::execution_context_for</innerconcept>
    <innerconcept refid="conceptfutures_1_1execution__context">futures::execution_context</innerconcept>
    <innerconcept refid="conceptfutures_1_1executor__for">futures::executor_for</innerconcept>
    <innerconcept refid="conceptfutures_1_1executor">futures::executor</innerconcept>
    <innerconcept refid="conceptfutures_1_1future__like">futures::future_like</innerconcept>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="group__error_1ga6b514c11923c676167997aae802757b8" prot="public" static="no" strong="yes">
        <type></type>
        <name>future_errc</name>
        <qualifiedname>futures::future_errc</qualifiedname>
        <enumvalue id="group__error_1gga6b514c11923c676167997aae802757b8a2c6bc6062e72db1c0915032943cb6452" prot="public">
          <name>broken_promise</name>
          <initializer>= 1</initializer>
          <briefdescription>
<para>The state owner got destroyed before the promise has been fulfilled. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__error_1gga6b514c11923c676167997aae802757b8a829037befd349f04ff71ddea385bdb9a" prot="public">
          <name>future_already_retrieved</name>
          <briefdescription>
<para>Attempted to retrieve a unique future twice. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__error_1gga6b514c11923c676167997aae802757b8a9327d6f7b9aca59b62b436696fd17a00" prot="public">
          <name>promise_already_satisfied</name>
          <briefdescription>
<para>Promise has already been fulfilled. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__error_1gga6b514c11923c676167997aae802757b8ac537dcef56fd6ff75592c0220fd3dae1" prot="public">
          <name>no_state</name>
          <briefdescription>
<para>There is no shared state we can access. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__error_1gga6b514c11923c676167997aae802757b8a10a2ce2357c08905b322144ac783b248" prot="public">
          <name>promise_uninitialized</name>
          <briefdescription>
<para>The promised hasn&apos;t been initialized yet. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__error_1gga6b514c11923c676167997aae802757b8ada2a787ba1dc30bb1fdcd016be91c974" prot="public">
          <name>packaged_task_uninitialized</name>
          <briefdescription>
<para>The packaged task hasn&apos;t been initialized yet. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__error_1gga6b514c11923c676167997aae802757b8af7626f3bd2a01c1cf17826a6a0302d7b" prot="public">
          <name>future_uninitialized</name>
          <briefdescription>
<para>The future hasn&apos;t been initialized yet. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__error_1gga6b514c11923c676167997aae802757b8a2002f5e501ea387b93c160010199797b" prot="public">
          <name>future_deferred</name>
          <briefdescription>
<para>Invalid operation on deferred future. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Error codes for futures. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/error.hpp" line="34" column="5" bodyfile="futures/error.hpp" bodystart="35" bodyend="52"/>
      </memberdef>
      <memberdef kind="enum" id="group__future-types_1ga2d9145fe40c699d6f0060bcddbf910a6" prot="public" static="no" strong="yes">
        <type></type>
        <name>future_status</name>
        <qualifiedname>futures::future_status</qualifiedname>
        <enumvalue id="group__future-types_1gga2d9145fe40c699d6f0060bcddbf910a6ab2fdab230a2c39f3595a947861863cb7" prot="public">
          <name>ready</name>
          <briefdescription>
<para>The operation state is ready. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__future-types_1gga2d9145fe40c699d6f0060bcddbf910a6a90272dda245ae1fb3cf197e91a8689dc" prot="public">
          <name>timeout</name>
          <briefdescription>
<para>The operation state did not become ready before specified timeout duration has passed. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__future-types_1gga2d9145fe40c699d6f0060bcddbf910a6a43fff3df3fc0b3417c86dc3040fb2d86" prot="public">
          <name>deferred</name>
          <briefdescription>
<para>The operation state contains a deferred function, so the result will be computed only when explicitly requested. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Specifies state of a future. </para>
        </briefdescription>
        <detaileddescription>
<para>Specifies state of a future as returned by <computeroutput>wait_for</computeroutput> and <computeroutput>wait_until</computeroutput> functions of <ref refid="classfutures_1_1basic__future" kindref="compound">basic_future</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/future_status.hpp" line="32" column="5" bodyfile="futures/future_status.hpp" bodystart="33" bodyend="42"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="group__future-types_1ga33c4a67592f57bcb5d04764d425c29a0" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class Executor</type>
            <defval>default_executor_type</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classfutures_1_1basic__future" kindref="compound">basic_future</ref>&lt; T, <ref refid="group__future-options_1ga7f03484ae7db4ae89f95bade537afc35" kindref="member">future_options</ref>&lt; <ref refid="structfutures_1_1executor__opt" kindref="compound">executor_opt</ref>&lt; Executor &gt; &gt; &gt;</type>
        <definition>using futures::future = typedef basic_future&lt;T, future_options&lt;executor_opt&lt;Executor&gt; &gt;&gt;</definition>
        <argsstring></argsstring>
        <name>future</name>
        <qualifiedname>futures::future</qualifiedname>
        <briefdescription>
<para>A simple future type similar to <computeroutput>std::future</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para>We should only use this future type for eager tasks that do not expect continuations. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/future.hpp" line="1002" column="5" bodyfile="futures/future.hpp" bodystart="1002" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__future-types_1ga691b06597181e3664dc3ab9a4976af6e" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class Executor</type>
            <defval>default_executor_type</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classfutures_1_1basic__future" kindref="compound">basic_future</ref>&lt; T, <ref refid="group__future-options_1ga7f03484ae7db4ae89f95bade537afc35" kindref="member">future_options</ref>&lt; <ref refid="structfutures_1_1executor__opt" kindref="compound">executor_opt</ref>&lt; Executor &gt;, <ref refid="structfutures_1_1continuable__opt" kindref="compound">continuable_opt</ref> &gt; &gt;</type>
        <definition>using futures::cfuture = typedef basic_future&lt; T, future_options&lt;executor_opt&lt;Executor&gt;, continuable_opt&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>cfuture</name>
        <qualifiedname>futures::cfuture</qualifiedname>
        <briefdescription>
<para>A future type with lazy continuations. </para>
        </briefdescription>
        <detaileddescription>
<para>Futures with lazy continuations contains a list of continuation tasks to be launched once the main task is complete.</para>
<para>This is what a <ref refid="group__launch_1gafcb2799edc3dab5292f720d81f7be75e" kindref="member">futures::async</ref> returns by default when the first function parameter is not a <ref refid="classfutures_1_1stop__token" kindref="compound">futures::stop_token</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/future.hpp" line="1013" column="5" bodyfile="futures/future.hpp" bodystart="1015" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__future-types_1ga594ffcefc7c53a3eab6431c9d9ef8f65" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class Executor</type>
            <defval>default_executor_type</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classfutures_1_1basic__future" kindref="compound">basic_future</ref>&lt; T, <ref refid="group__future-options_1ga7f03484ae7db4ae89f95bade537afc35" kindref="member">future_options</ref>&lt; <ref refid="structfutures_1_1executor__opt" kindref="compound">executor_opt</ref>&lt; Executor &gt;, <ref refid="structfutures_1_1continuable__opt" kindref="compound">continuable_opt</ref>, <ref refid="structfutures_1_1stoppable__opt" kindref="compound">stoppable_opt</ref> &gt; &gt;</type>
        <definition>using futures::jcfuture = typedef basic_future&lt; T, future_options&lt;executor_opt&lt;Executor&gt;, continuable_opt, stoppable_opt&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>jcfuture</name>
        <qualifiedname>futures::jcfuture</qualifiedname>
        <briefdescription>
<para>A future type with lazy continuations and stop tokens. </para>
        </briefdescription>
        <detaileddescription>
<para>It&apos;s a quite common use case that we need a way to cancel futures and jcfuture provides us with an even better way to do that.</para>
<para>This is what <ref refid="group__launch_1gafcb2799edc3dab5292f720d81f7be75e" kindref="member">futures::async</ref> returns when the first function parameter is a <ref refid="classfutures_1_1stop__token" kindref="compound">futures::stop_token</ref> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/future.hpp" line="1026" column="5" bodyfile="futures/future.hpp" bodystart="1028" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__future-types_1gaf9531b575c37bfe7fb80ff7e4c7b5b26" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class Executor</type>
            <defval>default_executor_type</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classfutures_1_1basic__future" kindref="compound">basic_future</ref>&lt; T, <ref refid="group__future-options_1ga7f03484ae7db4ae89f95bade537afc35" kindref="member">future_options</ref>&lt; <ref refid="structfutures_1_1executor__opt" kindref="compound">executor_opt</ref>&lt; Executor &gt;, <ref refid="structfutures_1_1always__deferred__opt" kindref="compound">always_deferred_opt</ref> &gt; &gt;</type>
        <definition>using futures::dfuture = typedef basic_future&lt; T, future_options&lt;executor_opt&lt;Executor&gt;, always_deferred_opt&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>dfuture</name>
        <qualifiedname>futures::dfuture</qualifiedname>
        <briefdescription>
<para>A deferred future type. </para>
        </briefdescription>
        <detaileddescription>
<para>This is a future type whose main task will only be launched when we wait for its results from another execution context.</para>
<para>This is what the function <ref refid="group__launch_1gaa3cac9f64c928b7c63acd65c6e17cc69" kindref="member">schedule</ref> returns when the first task parameter is not a stop token.</para>
<para>The state of this future stores the function to be run.</para>
<para>This future type supports continuations without the continuation lists of continuable futures. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/future.hpp" line="1045" column="5" bodyfile="futures/future.hpp" bodystart="1047" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__future-types_1gab6f89384255b61ed8004b61c25cfa0b0" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class Executor</type>
            <defval>default_executor_type</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classfutures_1_1basic__future" kindref="compound">basic_future</ref>&lt; T, <ref refid="group__future-options_1ga7f03484ae7db4ae89f95bade537afc35" kindref="member">future_options</ref>&lt; <ref refid="structfutures_1_1executor__opt" kindref="compound">executor_opt</ref>&lt; Executor &gt;, <ref refid="structfutures_1_1always__deferred__opt" kindref="compound">always_deferred_opt</ref> &gt; &gt;</type>
        <definition>using futures::jdfuture = typedef basic_future&lt; T, future_options&lt;executor_opt&lt;Executor&gt;, always_deferred_opt&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>jdfuture</name>
        <qualifiedname>futures::jdfuture</qualifiedname>
        <briefdescription>
<para>A deferred stoppable future type. </para>
        </briefdescription>
        <detaileddescription>
<para>This is a future type whose main task will only be launched when we wait for its results from another execution context.</para>
<para>Once the task is launched, it can be requested to stop through its stop source.</para>
<para>This is what the function <ref refid="group__launch_1gaa3cac9f64c928b7c63acd65c6e17cc69" kindref="member">schedule</ref> returns when the first task parameter is a stop token. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/future.hpp" line="1061" column="5" bodyfile="futures/future.hpp" bodystart="1063" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__future-types_1gaf8ae95b0fa154b6b1aed392fc0b12c2d" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classfutures_1_1basic__future" kindref="compound">basic_future</ref>&lt; T, <ref refid="group__future-options_1ga7f03484ae7db4ae89f95bade537afc35" kindref="member">future_options</ref>&lt;&gt; &gt;</type>
        <definition>using futures::vfuture = typedef basic_future&lt;T, future_options&lt;&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>vfuture</name>
        <qualifiedname>futures::vfuture</qualifiedname>
        <briefdescription>
<para>A future that simply holds a ready value. </para>
        </briefdescription>
        <detaileddescription>
<para>This is the future type we use for constant values. This is the future type we usually return from functions such as <ref refid="group__adaptors_1gacb4e00b6c170bb3ae76893524bfab046" kindref="member">make_ready_future</ref>.</para>
<para>These futures have no support for associated executors, continuations, or deferred tasks.</para>
<para>Like deferred futures, the operation state is stored inline. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/future.hpp" line="1078" column="5" bodyfile="futures/future.hpp" bodystart="1078" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__future-types_1ga7a01532e89adeadf5d9867b6bd767630" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class Executor</type>
            <defval>default_executor_type</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classfutures_1_1basic__future" kindref="compound">basic_future</ref>&lt; T, <ref refid="group__future-options_1ga7f03484ae7db4ae89f95bade537afc35" kindref="member">future_options</ref>&lt; <ref refid="structfutures_1_1executor__opt" kindref="compound">executor_opt</ref>&lt; Executor &gt;, <ref refid="structfutures_1_1shared__opt" kindref="compound">shared_opt</ref> &gt; &gt;</type>
        <definition>using futures::shared_future = typedef basic_future&lt;T, future_options&lt;executor_opt&lt;Executor&gt;, shared_opt&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>shared_future</name>
        <qualifiedname>futures::shared_future</qualifiedname>
        <briefdescription>
<para>A simple std::shared_future. </para>
        </briefdescription>
        <detaileddescription>
<para>This is what a futures::future::share() returns </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/future.hpp" line="1085" column="5" bodyfile="futures/future.hpp" bodystart="1086" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__future-types_1ga944b7785ed3941b348360bd463a29109" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class Executor</type>
            <defval>default_executor_type</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classfutures_1_1basic__future" kindref="compound">basic_future</ref>&lt; T, <ref refid="group__future-options_1ga7f03484ae7db4ae89f95bade537afc35" kindref="member">future_options</ref>&lt; <ref refid="structfutures_1_1executor__opt" kindref="compound">executor_opt</ref>&lt; Executor &gt;, <ref refid="structfutures_1_1continuable__opt" kindref="compound">continuable_opt</ref>, <ref refid="structfutures_1_1shared__opt" kindref="compound">shared_opt</ref> &gt; &gt;</type>
        <definition>using futures::shared_cfuture = typedef basic_future&lt; T, future_options&lt;executor_opt&lt;Executor&gt;, continuable_opt, shared_opt&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>shared_cfuture</name>
        <qualifiedname>futures::shared_cfuture</qualifiedname>
        <briefdescription>
<para>A shared future type with lazy continuations. </para>
        </briefdescription>
        <detaileddescription>
<para>This is what a <ref refid="classfutures_1_1basic__future_1afdc42ec4d91e68b180276045f8003255" kindref="member">futures::cfuture::share()</ref> returns </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/future.hpp" line="1093" column="5" bodyfile="futures/future.hpp" bodystart="1095" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__future-types_1ga85aeb742e0facea42147c5bca36dbafe" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class Executor</type>
            <defval>default_executor_type</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classfutures_1_1basic__future" kindref="compound">basic_future</ref>&lt; T, <ref refid="group__future-options_1ga7f03484ae7db4ae89f95bade537afc35" kindref="member">future_options</ref>&lt; <ref refid="structfutures_1_1executor__opt" kindref="compound">executor_opt</ref>&lt; Executor &gt;, <ref refid="structfutures_1_1continuable__opt" kindref="compound">continuable_opt</ref>, <ref refid="structfutures_1_1stoppable__opt" kindref="compound">stoppable_opt</ref>, <ref refid="structfutures_1_1shared__opt" kindref="compound">shared_opt</ref> &gt; &gt;</type>
        <definition>using futures::shared_jcfuture = typedef basic_future&lt; T, future_options&lt; executor_opt&lt;Executor&gt;, continuable_opt, stoppable_opt, shared_opt&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>shared_jcfuture</name>
        <qualifiedname>futures::shared_jcfuture</qualifiedname>
        <briefdescription>
<para>A shared future type with lazy continuations and stop tokens. </para>
        </briefdescription>
        <detaileddescription>
<para>This is what a <ref refid="classfutures_1_1basic__future_1afdc42ec4d91e68b180276045f8003255" kindref="member">futures::jcfuture::share()</ref> returns </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/future.hpp" line="1102" column="5" bodyfile="futures/future.hpp" bodystart="1108" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__future-types_1gac625c612509f8d6e983f18b30d4a50c7" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class Executor</type>
            <defval>default_executor_type</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classfutures_1_1basic__future" kindref="compound">basic_future</ref>&lt; T, <ref refid="group__future-options_1ga7f03484ae7db4ae89f95bade537afc35" kindref="member">future_options</ref>&lt; <ref refid="structfutures_1_1executor__opt" kindref="compound">executor_opt</ref>&lt; Executor &gt;, <ref refid="structfutures_1_1always__deferred__opt" kindref="compound">always_deferred_opt</ref>, <ref refid="structfutures_1_1shared__opt" kindref="compound">shared_opt</ref> &gt; &gt;</type>
        <definition>using futures::shared_dfuture = typedef basic_future&lt; T, future_options&lt;executor_opt&lt;Executor&gt;, always_deferred_opt, shared_opt&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>shared_dfuture</name>
        <qualifiedname>futures::shared_dfuture</qualifiedname>
        <briefdescription>
<para>A shared future type with deferred task. </para>
        </briefdescription>
        <detaileddescription>
<para>This is what a <ref refid="classfutures_1_1basic__future_1afdc42ec4d91e68b180276045f8003255" kindref="member">futures::dfuture::share()</ref> returns </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/future.hpp" line="1115" column="5" bodyfile="futures/future.hpp" bodystart="1117" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__future-types_1ga6ed365c544f18f9e09c5a291754cd3d3" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class Executor</type>
            <defval>default_executor_type</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classfutures_1_1basic__future" kindref="compound">basic_future</ref>&lt; T, <ref refid="group__future-options_1ga7f03484ae7db4ae89f95bade537afc35" kindref="member">future_options</ref>&lt; <ref refid="structfutures_1_1executor__opt" kindref="compound">executor_opt</ref>&lt; Executor &gt;, <ref refid="structfutures_1_1stoppable__opt" kindref="compound">stoppable_opt</ref>, <ref refid="structfutures_1_1always__deferred__opt" kindref="compound">always_deferred_opt</ref>, <ref refid="structfutures_1_1shared__opt" kindref="compound">shared_opt</ref> &gt; &gt;</type>
        <definition>using futures::shared_jdfuture = typedef basic_future&lt; T, future_options&lt; executor_opt&lt;Executor&gt;, stoppable_opt, always_deferred_opt, shared_opt&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>shared_jdfuture</name>
        <qualifiedname>futures::shared_jdfuture</qualifiedname>
        <briefdescription>
<para>A shared future type with deferred task and stop token. </para>
        </briefdescription>
        <detaileddescription>
<para>This is what a <ref refid="classfutures_1_1basic__future_1afdc42ec4d91e68b180276045f8003255" kindref="member">futures::jdfuture::share()</ref> returns </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/future.hpp" line="1124" column="5" bodyfile="futures/future.hpp" bodystart="1130" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__future-types_1ga0dbca35f60e6be3e06cf318a67042dd7" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classfutures_1_1basic__future" kindref="compound">basic_future</ref>&lt; T, <ref refid="group__future-options_1ga7f03484ae7db4ae89f95bade537afc35" kindref="member">future_options</ref>&lt; <ref refid="structfutures_1_1shared__opt" kindref="compound">shared_opt</ref> &gt; &gt;</type>
        <definition>using futures::shared_vfuture = typedef basic_future&lt;T, future_options&lt;shared_opt&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>shared_vfuture</name>
        <qualifiedname>futures::shared_vfuture</qualifiedname>
        <briefdescription>
<para>A shared future that simply holds a ready value. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/future.hpp" line="1134" column="5" bodyfile="futures/future.hpp" bodystart="1134" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacefutures_1a2616ae270c50b96ac0cc23d25521fe3e" prot="public" static="no">
        <type>std::partial_ordering</type>
        <definition>using futures::partial_ordering = typedef std::partial_ordering</definition>
        <argsstring></argsstring>
        <name>partial_ordering</name>
        <qualifiedname>futures::partial_ordering</qualifiedname>
        <briefdescription>
<para>the result type of 3-way comparison that supports all 6 operators, </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/compare/partial_ordering.hpp" line="28" column="5" bodyfile="futures/algorithm/compare/partial_ordering.hpp" bodystart="28" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacefutures_1a6cdf610a1446f3290b241594d29c07f1" prot="public" static="no">
        <type>std::strong_ordering</type>
        <definition>using futures::strong_ordering = typedef std::strong_ordering</definition>
        <argsstring></argsstring>
        <name>strong_ordering</name>
        <qualifiedname>futures::strong_ordering</qualifiedname>
        <briefdescription>
<para>the result type of 3-way comparison that supports all 6 operators and is substitutable </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/compare/strong_ordering.hpp" line="30" column="5" bodyfile="futures/algorithm/compare/strong_ordering.hpp" bodystart="30" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacefutures_1aaa4179da18ef4ccba8471045493daca5" prot="public" static="no">
        <type>std::weak_ordering</type>
        <definition>using futures::weak_ordering = typedef std::weak_ordering</definition>
        <argsstring></argsstring>
        <name>weak_ordering</name>
        <qualifiedname>futures::weak_ordering</qualifiedname>
        <briefdescription>
<para>the result type of 3-way comparison that supports all 6 operators, does </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/compare/weak_ordering.hpp" line="29" column="5" bodyfile="futures/algorithm/compare/weak_ordering.hpp" bodystart="29" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__partitioners_1ga1dfbb885c6bb2f86870d55160dd16783" prot="public" static="no">
        <type>__see_below__</type>
        <definition>using futures::default_partitioner = typedef __see_below__</definition>
        <argsstring></argsstring>
        <name>default_partitioner</name>
        <qualifiedname>futures::default_partitioner</qualifiedname>
        <briefdescription>
<para>Default partitioner used by parallel algorithms. </para>
        </briefdescription>
        <detaileddescription>
<para>Its type and parameters might change </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/partitioner/default_partitioner.hpp" line="35" column="5" bodyfile="futures/algorithm/partitioner/default_partitioner.hpp" bodystart="35" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__partitioners_1gace2856b25ae230b1d91b1e1a79267cf5" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class P</type>
          </param>
          <param>
            <type>class I</type>
          </param>
          <param>
            <type>class S</type>
            <defval>I</defval>
          </param>
        </templateparamlist>
        <type>std::bool_constant&lt; partitioner_for&lt; P, I, S &gt; &gt;</type>
        <definition>using futures::is_partitioner_for = typedef std::bool_constant&lt;partitioner_for&lt;P, I, S&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_partitioner_for</name>
        <qualifiedname>futures::is_partitioner_for</qualifiedname>
        <briefdescription>
<para>Determine if P is a valid partitioner for the iterator range [I,S]. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/partitioner/partitioner_for.hpp" line="46" column="5" bodyfile="futures/algorithm/partitioner/partitioner_for.hpp" bodystart="48" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__execution-policies_1gaf5d088ab9052836d3d58c62a02697e26" prot="public" static="no">
        <type>std::execution::sequenced_policy</type>
        <definition>using futures::sequenced_policy = typedef std::execution::sequenced_policy</definition>
        <argsstring></argsstring>
        <name>sequenced_policy</name>
        <qualifiedname>futures::sequenced_policy</qualifiedname>
        <briefdescription>
<para>Class representing a type for a sequenced_policy tag. </para>
        </briefdescription>
        <detaileddescription>
<para>This tag type is an alias to <computeroutput>std::execution::sequenced_policy</computeroutput> whenever it&apos;s available. Otherwise it&apos;s defined as an individual type. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/policies.hpp" line="50" column="5" bodyfile="futures/algorithm/policies.hpp" bodystart="50" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__execution-policies_1gaeb6a426f21b797b63d6cfd5f1a4585ee" prot="public" static="no">
        <type>std::execution::parallel_policy</type>
        <definition>using futures::parallel_policy = typedef std::execution::parallel_policy</definition>
        <argsstring></argsstring>
        <name>parallel_policy</name>
        <qualifiedname>futures::parallel_policy</qualifiedname>
        <briefdescription>
<para>Class representing a type for a parallel_policy tag. </para>
        </briefdescription>
        <detaileddescription>
<para>This tag type is an alias to <computeroutput>std::execution::parallel_policy</computeroutput> whenever it&apos;s available. Otherwise it&apos;s defined as an individual type. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/policies.hpp" line="61" column="5" bodyfile="futures/algorithm/policies.hpp" bodystart="61" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__execution-policies_1ga1cfc7e6ec53363f996022ad8282b0cfe" prot="public" static="no">
        <type>std::execution::parallel_unsequenced_policy</type>
        <definition>using futures::parallel_unsequenced_policy = typedef std::execution:: parallel_unsequenced_policy</definition>
        <argsstring></argsstring>
        <name>parallel_unsequenced_policy</name>
        <qualifiedname>futures::parallel_unsequenced_policy</qualifiedname>
        <briefdescription>
<para>Class representing a type for a parallel_unsequenced_policy tag. </para>
        </briefdescription>
        <detaileddescription>
<para>This tag type is an alias to <computeroutput>std::execution::parallel_unsequenced_policy</computeroutput> whenever it&apos;s available. Otherwise it&apos;s defined as an individual type. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/policies.hpp" line="73" column="5" bodyfile="futures/algorithm/policies.hpp" bodystart="74" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__execution-policies_1gabaa708215fbcb22a94cc04f7ef726059" prot="public" static="no">
        <type>std::execution::unsequenced_policy</type>
        <definition>using futures::unsequenced_policy = typedef std::execution::unsequenced_policy</definition>
        <argsstring></argsstring>
        <name>unsequenced_policy</name>
        <qualifiedname>futures::unsequenced_policy</qualifiedname>
        <briefdescription>
<para>Class representing a type for an unsequenced_policy tag. </para>
        </briefdescription>
        <detaileddescription>
<para>This tag type is an alias to <computeroutput>std::execution::unsequenced_policy</computeroutput> whenever it&apos;s available. Otherwise it&apos;s defined as an individual type. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/policies.hpp" line="85" column="5" bodyfile="futures/algorithm/policies.hpp" bodystart="85" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1gacd1a119404dd4b52bcb267a28c530720" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class...</type>
            <declname>Ts</declname>
            <defname>Ts</defname>
          </param>
        </templateparamlist>
        <type>std::common_comparison_category&lt; Ts... &gt;</type>
        <definition>using futures::common_comparison_category = typedef std::common_comparison_category&lt;Ts...&gt;</definition>
        <argsstring></argsstring>
        <name>common_comparison_category</name>
        <qualifiedname>futures::common_comparison_category</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::equality_comparable</computeroutput> concept. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/utility/compare/three_way_comparable"><computeroutput>std::three_way_comparable</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/common_comparison_category.hpp" line="48" column="5" bodyfile="futures/algorithm/traits/common_comparison_category.hpp" bodystart="48" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1gaa31c7a165f142f3cbb7523128b649038" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class...</type>
            <declname>Ts</declname>
            <defname>Ts</defname>
          </param>
        </templateparamlist>
        <type>typename <ref refid="group__traits_1gacd1a119404dd4b52bcb267a28c530720" kindref="member">common_comparison_category</ref>&lt; Ts... &gt;::type</type>
        <definition>using futures::common_comparison_category_t = typedef typename common_comparison_category&lt; Ts...&gt;::type</definition>
        <argsstring></argsstring>
        <name>common_comparison_category_t</name>
        <qualifiedname>futures::common_comparison_category_t</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::equality_comparable</computeroutput> concept.   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/utility/compare/three_way_comparable"><computeroutput>std::three_way_comparable</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/common_comparison_category.hpp" line="76" column="5" bodyfile="futures/algorithm/traits/common_comparison_category.hpp" bodystart="77" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1ga7bda1c11fe675de42221596af9f0df5f" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class LHS</type>
          </param>
          <param>
            <type>class RHS</type>
          </param>
        </templateparamlist>
        <type>std::bool_constant&lt; std::assignable_from&lt; LHS, RHS &gt; &gt;</type>
        <definition>using futures::is_assignable_from = typedef std::bool_constant&lt; std::assignable_from&lt;LHS, RHS&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_assignable_from</name>
        <qualifiedname>futures::is_assignable_from</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::assignable_from</computeroutput> concept. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/concepts/assignable_from"><computeroutput>std::assignable_from</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_assignable_from.hpp" line="38" column="5" bodyfile="futures/algorithm/traits/is_assignable_from.hpp" bodystart="39" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1ga76db62394fec337406efe0efe4680339" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::bool_constant&lt; std::bidirectional_iterator&lt; T &gt; &gt;</type>
        <definition>using futures::is_bidirectional_iterator = typedef std::bool_constant&lt; std::bidirectional_iterator&lt;T&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_bidirectional_iterator</name>
        <qualifiedname>futures::is_bidirectional_iterator</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::bidirectional_iterator</computeroutput> concept. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/iterator/bidirectional_iterator"><computeroutput>std::bidirectional_iterator</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_bidirectional_iterator.hpp" line="40" column="5" bodyfile="futures/algorithm/traits/is_bidirectional_iterator.hpp" bodystart="41" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1gaa14660ab0fd62ba08cc33db046c7f3b1" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>detail::conjunction&lt; std::is_destructible&lt; T &gt;, std::is_constructible&lt; T, Args... &gt; &gt;</type>
        <definition>using futures::is_constructible_from = typedef detail:: conjunction&lt;std::is_destructible&lt;T&gt;, std::is_constructible&lt;T, Args...&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_constructible_from</name>
        <qualifiedname>futures::is_constructible_from</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::constructible_from</computeroutput> concept. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/concepts/constructible_from"><computeroutput>std::constructible_from</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_constructible_from.hpp" line="35" column="5" bodyfile="futures/algorithm/traits/is_constructible_from.hpp" bodystart="36" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1ga478ba461a135cc0e9c291252ec9b2d8f" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class From</type>
          </param>
          <param>
            <type>class To</type>
          </param>
        </templateparamlist>
        <type>std::bool_constant&lt; std::convertible_to&lt; From, To &gt; &gt;</type>
        <definition>using futures::is_convertible_to = typedef std::bool_constant&lt;std::convertible_to&lt;From, To&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_convertible_to</name>
        <qualifiedname>futures::is_convertible_to</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::convertible_to</computeroutput> concept. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/concepts/convertible_to"><computeroutput>std::convertible_to</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_convertible_to.hpp" line="37" column="5" bodyfile="futures/algorithm/traits/is_convertible_to.hpp" bodystart="37" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1gafeeb5e8c14faf5518660bbbd61cadf2b" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::bool_constant&lt; std::copyable&lt; T &gt; &gt;</type>
        <definition>using futures::is_copyable = typedef std::bool_constant&lt;std::copyable&lt;T&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_copyable</name>
        <qualifiedname>futures::is_copyable</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::copyable</computeroutput> concept. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/concepts/copyable"><computeroutput>std::copyable</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_copyable.hpp" line="38" column="5" bodyfile="futures/algorithm/traits/is_copyable.hpp" bodystart="38" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1gade601510289810972f9caf8e2b4c73fb" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::bool_constant&lt; std::default_initializable&lt; T &gt; &gt;</type>
        <definition>using futures::is_default_initializable = typedef std::bool_constant&lt; std::default_initializable&lt;T&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_default_initializable</name>
        <qualifiedname>futures::is_default_initializable</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::default_initializable</computeroutput> concept. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/concepts/default_initializable"><computeroutput>std::default_initializable</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_default_initializable.hpp" line="39" column="5" bodyfile="futures/algorithm/traits/is_default_initializable.hpp" bodystart="40" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1ga1e386f4f05388c302d714c7d1a2c6aa2" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class Derived</type>
          </param>
          <param>
            <type>class Base</type>
          </param>
        </templateparamlist>
        <type>std::bool_constant&lt; derived_from&lt; Derived, Base &gt; &gt;</type>
        <definition>using futures::is_derived_from = typedef std::bool_constant&lt;derived_from&lt;Derived, Base&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_derived_from</name>
        <qualifiedname>futures::is_derived_from</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>derived_from</computeroutput> concept. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/concepts/derived_from"><computeroutput>std::derived_from</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_derived_from.hpp" line="40" column="5" bodyfile="futures/algorithm/traits/is_derived_from.hpp" bodystart="40" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1ga700cff8b3f85ddd38376e54c9ca3e6b8" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::bool_constant&lt; std::equality_comparable&lt; T &gt; &gt;</type>
        <definition>using futures::is_equality_comparable = typedef std::bool_constant&lt; std::equality_comparable&lt;T&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_equality_comparable</name>
        <qualifiedname>futures::is_equality_comparable</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::equality_comparable</computeroutput> concept. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/concepts/equality_comparable"><computeroutput>std::equality_comparable</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_equality_comparable.hpp" line="42" column="5" bodyfile="futures/algorithm/traits/is_equality_comparable.hpp" bodystart="43" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1ga33c9e5b16ea99aea746e3bffa28cc56c" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::bool_constant&lt; std::equality_comparable_with&lt; T, U &gt; &gt;</type>
        <definition>using futures::is_equality_comparable_with = typedef std::bool_constant&lt; std::equality_comparable_with&lt;T, U&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_equality_comparable_with</name>
        <qualifiedname>futures::is_equality_comparable_with</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::equality_comparable_with</computeroutput> concept. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/concepts/equality_comparable_with"><computeroutput>std::equality_comparable_with</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_equality_comparable_with.hpp" line="43" column="5" bodyfile="futures/algorithm/traits/is_equality_comparable_with.hpp" bodystart="44" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1ga848d84bbb112bc916c2efd34da93a572" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::bool_constant&lt; std::forward_iterator&lt; T &gt; &gt;</type>
        <definition>using futures::is_forward_iterator = typedef std::bool_constant&lt;std::forward_iterator&lt;T&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_forward_iterator</name>
        <qualifiedname>futures::is_forward_iterator</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::forward_iterator</computeroutput> concept. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/iterator/forward_iterator"><computeroutput>std::forward_iterator</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_forward_iterator.hpp" line="42" column="5" bodyfile="futures/algorithm/traits/is_forward_iterator.hpp" bodystart="42" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1ga33d3975351d7b6285a7e0c8663e96c84" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class I</type>
          </param>
        </templateparamlist>
        <type>std::bool_constant&lt; std::incrementable&lt; I &gt; &gt;</type>
        <definition>using futures::is_incrementable = typedef std::bool_constant&lt;std::incrementable&lt;I&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_incrementable</name>
        <qualifiedname>futures::is_incrementable</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::incrementable</computeroutput> concept. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/iterator/incrementable"><computeroutput>std::incrementable</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_incrementable.hpp" line="38" column="5" bodyfile="futures/algorithm/traits/is_incrementable.hpp" bodystart="38" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1gacec3cf84299f155f1a34a4984c69a8e3" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class I1</type>
          </param>
          <param>
            <type>class I2</type>
          </param>
        </templateparamlist>
        <type>__see_below__</type>
        <definition>using futures::is_indirectly_binary_invocable = typedef __see_below__</definition>
        <argsstring></argsstring>
        <name>is_indirectly_binary_invocable</name>
        <qualifiedname>futures::is_indirectly_binary_invocable</qualifiedname>
        <briefdescription>
<para>Determine if a function can be invoke with the value type of both iterators. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_indirectly_binary_invocable.hpp" line="39" column="5" bodyfile="futures/algorithm/traits/is_indirectly_binary_invocable.hpp" bodystart="39" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1ga5d997016e1af193a53e63e8d35454110" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::bool_constant&lt; std::indirectly_readable&lt; T &gt; &gt;</type>
        <definition>using futures::is_indirectly_readable = typedef std::bool_constant&lt; std::indirectly_readable&lt;T&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_indirectly_readable</name>
        <qualifiedname>futures::is_indirectly_readable</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::indirectly_readable</computeroutput> concept. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/iterator/indirectly_readable"><computeroutput>std::indirectly_readable</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_indirectly_readable.hpp" line="39" column="5" bodyfile="futures/algorithm/traits/is_indirectly_readable.hpp" bodystart="40" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1ga8a78009173a34f27d5d088459b744253" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class I</type>
          </param>
        </templateparamlist>
        <type>std::bool_constant&lt; std::indirectly_unary_invocable&lt; F, I &gt; &gt;</type>
        <definition>using futures::is_indirectly_unary_invocable = typedef std::bool_constant&lt; std::indirectly_unary_invocable&lt;F, I&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_indirectly_unary_invocable</name>
        <qualifiedname>futures::is_indirectly_unary_invocable</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::indirectly_unary_invocable</computeroutput> concept. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/iterator/indirectly_unary_invocable"><computeroutput>std::indirectly_unary_invocable</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_indirectly_unary_invocable.hpp" line="42" column="5" bodyfile="futures/algorithm/traits/is_indirectly_unary_invocable.hpp" bodystart="43" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1gafdc7cbe83b02548031e1457c533b0413" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::bool_constant&lt; std::input_iterator&lt; T &gt; &gt;</type>
        <definition>using futures::is_input_iterator = typedef std::bool_constant&lt;std::input_iterator&lt;T&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_input_iterator</name>
        <qualifiedname>futures::is_input_iterator</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::input_iterator</computeroutput> concept. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/iterator/input_iterator"><computeroutput>std::input_iterator</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_input_iterator.hpp" line="39" column="5" bodyfile="futures/algorithm/traits/is_input_iterator.hpp" bodystart="39" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1ga787d4f89658a472119f07b2b0797000f" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::bool_constant&lt; std::is_input_or_output_iterator&lt; T &gt; &gt;</type>
        <definition>using futures::is_input_or_output_iterator = typedef std::bool_constant&lt; std::is_input_or_output_iterator&lt;T&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_input_or_output_iterator</name>
        <qualifiedname>futures::is_input_or_output_iterator</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::is_input_or_output_iterator</computeroutput> concept. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/iterator/is_input_or_output_iterator"><computeroutput>std::is_input_or_output_iterator</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_input_or_output_iterator.hpp" line="38" column="5" bodyfile="futures/algorithm/traits/is_input_or_output_iterator.hpp" bodystart="39" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1gaf1bf7865ae3e06fd952ef1f861a28f70" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::bool_constant&lt; std::is_input_range&lt; T &gt; &gt;</type>
        <definition>using futures::is_input_range = typedef std::bool_constant&lt;std::is_input_range&lt;T&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_input_range</name>
        <qualifiedname>futures::is_input_range</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::input_range</computeroutput> concept. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/ranges/input_range"><computeroutput>std::ranges::input_range</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_input_range.hpp" line="39" column="5" bodyfile="futures/algorithm/traits/is_input_range.hpp" bodystart="39" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1gaf041a0c651e1e59ea18df0e2dc2dc8fe" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::bool_constant&lt; std::movable&lt; T &gt; &gt;</type>
        <definition>using futures::is_movable = typedef std::bool_constant&lt;std::movable&lt;T&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_movable</name>
        <qualifiedname>futures::is_movable</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::movable</computeroutput> concept. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/concepts/movable"><computeroutput>std::movable</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_movable.hpp" line="39" column="5" bodyfile="futures/algorithm/traits/is_movable.hpp" bodystart="39" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1gae4e9bd33e6ed647165d69f3ece27935d" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::bool_constant&lt; std::move_constructible&lt; T &gt; &gt;</type>
        <definition>using futures::is_move_constructible = typedef std::bool_constant&lt;std::move_constructible&lt;T&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_move_constructible</name>
        <qualifiedname>futures::is_move_constructible</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::move_constructible</computeroutput> concept. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/concepts/move_constructible"><computeroutput>std::move_constructible</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_move_constructible.hpp" line="39" column="5" bodyfile="futures/algorithm/traits/is_move_constructible.hpp" bodystart="39" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1ga0a68b1cb70778749f176868ea5489453" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::bool_constant&lt; std::random_access_iterator&lt; T &gt; &gt;</type>
        <definition>using futures::is_random_access_iterator = typedef std::bool_constant&lt; std::random_access_iterator&lt;T&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_random_access_iterator</name>
        <qualifiedname>futures::is_random_access_iterator</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::random_access_iterator</computeroutput> concept. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/iterator/random_access_iterator"><computeroutput>std::random_access_iterator</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_random_access_iterator.hpp" line="41" column="5" bodyfile="futures/algorithm/traits/is_random_access_iterator.hpp" bodystart="42" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1gaea08f93eea232d08478c9cc04773e116" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::bool_constant&lt; std::range&lt; T &gt; &gt;</type>
        <definition>using futures::is_range = typedef std::bool_constant&lt;std::range&lt;T&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_range</name>
        <qualifiedname>futures::is_range</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::range</computeroutput> concept. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/ranges/range"><computeroutput>std::ranges::range</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_range.hpp" line="38" column="5" bodyfile="futures/algorithm/traits/is_range.hpp" bodystart="38" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1ga6c651460b5dfa33f143fef4514c3120b" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::bool_constant&lt; std::regular&lt; T &gt; &gt;</type>
        <definition>using futures::is_regular = typedef std::bool_constant&lt;std::regular&lt;T&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_regular</name>
        <qualifiedname>futures::is_regular</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::regular</computeroutput> concept. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/concepts/regular"><computeroutput>std::regular</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_regular.hpp" line="38" column="5" bodyfile="futures/algorithm/traits/is_regular.hpp" bodystart="38" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1ga1f7dc3c45de0abcd0e466f853e283679" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::bool_constant&lt; std::semiregular&lt; T &gt; &gt;</type>
        <definition>using futures::is_semiregular = typedef std::bool_constant&lt;std::semiregular&lt;T&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_semiregular</name>
        <qualifiedname>futures::is_semiregular</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::semiregular</computeroutput> concept. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/concepts/semiregular"><computeroutput>std::semiregular</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_semiregular.hpp" line="37" column="5" bodyfile="futures/algorithm/traits/is_semiregular.hpp" bodystart="37" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1ga5dea935029d8615e75f76c5d244f1a46" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class S</type>
          </param>
          <param>
            <type>class I</type>
          </param>
        </templateparamlist>
        <type>std::bool_constant&lt; std::sentinel_for&lt; S, I &gt; &gt;</type>
        <definition>using futures::is_sentinel_for = typedef std::bool_constant&lt;std::sentinel_for&lt;S, I&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_sentinel_for</name>
        <qualifiedname>futures::is_sentinel_for</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::sentinel_for</computeroutput> concept. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/iterator/sentinel_for"><computeroutput>std::sentinel_for</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_sentinel_for.hpp" line="38" column="5" bodyfile="futures/algorithm/traits/is_sentinel_for.hpp" bodystart="38" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1gaced3438d14261ee82a0efa2cff8a08e4" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::bool_constant&lt; std::swappable&lt; T &gt; &gt;</type>
        <definition>using futures::is_swappable = typedef std::bool_constant&lt;std::swappable&lt;T&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_swappable</name>
        <qualifiedname>futures::is_swappable</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::swappable</computeroutput> concept. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/concepts/swappable"><computeroutput>std::swappable</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_swappable.hpp" line="37" column="5" bodyfile="futures/algorithm/traits/is_swappable.hpp" bodystart="37" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1gac22a6b82a79830ec1177653c62c89597" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class Cat</type>
            <defval>std::partial_ordering</defval>
          </param>
        </templateparamlist>
        <type>std::bool_constant&lt; std::three_way_comparable&lt; T, Cat &gt; &gt;</type>
        <definition>using futures::is_three_way_comparable = typedef std::bool_constant&lt; std::three_way_comparable&lt;T, Cat&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_three_way_comparable</name>
        <qualifiedname>futures::is_three_way_comparable</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::equality_comparable</computeroutput> concept. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/utility/compare/three_way_comparable"><computeroutput>std::three_way_comparable</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_three_way_comparable.hpp" line="48" column="5" bodyfile="futures/algorithm/traits/is_three_way_comparable.hpp" bodystart="49" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1ga7d342b63b24fa9b3a399a8be75a909b1" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
          <param>
            <type>class Cat</type>
            <defval>std::partial_ordering</defval>
          </param>
        </templateparamlist>
        <type>std::bool_constant&lt; std::three_way_comparable_with&lt; T, U, Cat &gt; &gt;</type>
        <definition>using futures::is_three_way_comparable_with = typedef std::bool_constant&lt; std::three_way_comparable_with&lt;T, U, Cat&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_three_way_comparable_with</name>
        <qualifiedname>futures::is_three_way_comparable_with</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::equality_comparable_with</computeroutput> concept. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/utility/compare/three_way_comparable"><computeroutput>std::three_way_comparable</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_three_way_comparable_with.hpp" line="46" column="5" bodyfile="futures/algorithm/traits/is_three_way_comparable_with.hpp" bodystart="47" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1gacca0150c5cccef1847a596ff7dbfb85c" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::bool_constant&lt; std::totally_ordered&lt; T &gt; &gt;</type>
        <definition>using futures::is_totally_ordered = typedef std::bool_constant&lt;std::totally_ordered&lt;T&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_totally_ordered</name>
        <qualifiedname>futures::is_totally_ordered</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::totally_ordered</computeroutput> concept. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/concepts/totally_ordered"><computeroutput>std::totally_ordered</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_totally_ordered.hpp" line="43" column="5" bodyfile="futures/algorithm/traits/is_totally_ordered.hpp" bodystart="43" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1ga3e7a594dd861beb0287aab525b8d44d8" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>std::bool_constant&lt; std::totally_ordered_with&lt; T, U &gt; &gt;</type>
        <definition>using futures::is_totally_ordered_with = typedef std::bool_constant&lt; std::totally_ordered_with&lt;T, U&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_totally_ordered_with</name>
        <qualifiedname>futures::is_totally_ordered_with</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::totally_ordered_with</computeroutput> concept. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/concepts/totally_ordered"><computeroutput>std::totally_ordered</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_totally_ordered_with.hpp" line="41" column="5" bodyfile="futures/algorithm/traits/is_totally_ordered_with.hpp" bodystart="42" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1ga9420a5b6af74d0339ded7b71b49aae5c" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class I</type>
          </param>
        </templateparamlist>
        <type>std::bool_constant&lt; std::weakly_incrementable&lt; T &gt; &gt;</type>
        <definition>using futures::is_weakly_incrementable = typedef std::bool_constant&lt; std::weakly_incrementable&lt;T&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_weakly_incrementable</name>
        <qualifiedname>futures::is_weakly_incrementable</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::weakly_incrementable</computeroutput> concept. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/iterator/weakly_incrementable"><computeroutput>std::weakly_incrementable</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_weakly_incrementable.hpp" line="38" column="5" bodyfile="futures/algorithm/traits/is_weakly_incrementable.hpp" bodystart="39" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1ga0cd4722e248e01dcf1f077f5b64dd135" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::iter_difference</type>
        <definition>using futures::iter_difference = typedef std::iter_difference</definition>
        <argsstring></argsstring>
        <name>iter_difference</name>
        <qualifiedname>futures::iter_difference</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to <computeroutput>std::iter_difference</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/iterator/iter_t"><computeroutput>std::iter_difference</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/iter_difference.hpp" line="43" column="5" bodyfile="futures/algorithm/traits/iter_difference.hpp" bodystart="43" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1gadb88ead4be9c831ffd25b07850d1f1db" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>typename <ref refid="group__traits_1ga0cd4722e248e01dcf1f077f5b64dd135" kindref="member">iter_difference</ref>&lt; T &gt;::type</type>
        <definition>using futures::iter_difference_t = typedef typename iter_difference&lt;T&gt;::type</definition>
        <argsstring></argsstring>
        <name>iter_difference_t</name>
        <qualifiedname>futures::iter_difference_t</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to <computeroutput>std::iter_difference</computeroutput>   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/iterator/iter_t"><computeroutput>std::iter_difference</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/iter_difference.hpp" line="67" column="5" bodyfile="futures/algorithm/traits/iter_difference.hpp" bodystart="67" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1gae8d16e13ff22db3256af14a4d4b89fa9" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::iter_reference</type>
        <definition>using futures::iter_reference = typedef std::iter_reference</definition>
        <argsstring></argsstring>
        <name>iter_reference</name>
        <qualifiedname>futures::iter_reference</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to <computeroutput>std::iter_reference</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/iterator/iter_t"><computeroutput>std::iter_reference</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/iter_reference.hpp" line="39" column="5" bodyfile="futures/algorithm/traits/iter_reference.hpp" bodystart="39" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1ga4b1badc7c239d872ac366d4a8c57101a" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>typename <ref refid="group__traits_1gae8d16e13ff22db3256af14a4d4b89fa9" kindref="member">iter_reference</ref>&lt; T &gt;::type</type>
        <definition>using futures::iter_reference_t = typedef typename iter_reference&lt;T&gt;::type</definition>
        <argsstring></argsstring>
        <name>iter_reference_t</name>
        <qualifiedname>futures::iter_reference_t</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to <computeroutput>std::iter_reference</computeroutput>   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/iterator/iter_t"><computeroutput>std::iter_reference</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/iter_reference.hpp" line="52" column="5" bodyfile="futures/algorithm/traits/iter_reference.hpp" bodystart="52" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1ga512a5a98c50c6dd379e05bb4934ceed2" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::iter_rvalue_reference</type>
        <definition>using futures::iter_rvalue_reference = typedef std::iter_rvalue_reference</definition>
        <argsstring></argsstring>
        <name>iter_rvalue_reference</name>
        <qualifiedname>futures::iter_rvalue_reference</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to <computeroutput>std::iter_rvalue_reference</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/iterator/iter_t"><computeroutput>std::iter_rvalue_reference</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/iter_rvalue_reference.hpp" line="38" column="5" bodyfile="futures/algorithm/traits/iter_rvalue_reference.hpp" bodystart="38" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1ga2de87617ebb91ba233b7d4f5ee08e703" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>typename <ref refid="group__traits_1ga512a5a98c50c6dd379e05bb4934ceed2" kindref="member">iter_rvalue_reference</ref>&lt; T &gt;::type</type>
        <definition>using futures::iter_rvalue_reference_t = typedef typename iter_rvalue_reference&lt;T&gt;::type</definition>
        <argsstring></argsstring>
        <name>iter_rvalue_reference_t</name>
        <qualifiedname>futures::iter_rvalue_reference_t</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to <computeroutput>std::iter_rvalue_reference</computeroutput>   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/iterator/iter_t"><computeroutput>std::iter_rvalue_reference</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/iter_rvalue_reference.hpp" line="51" column="5" bodyfile="futures/algorithm/traits/iter_rvalue_reference.hpp" bodystart="51" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1gab7bdd46a3627a696302c30934567f51d" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::iter_value</type>
        <definition>using futures::iter_value = typedef std::iter_value</definition>
        <argsstring></argsstring>
        <name>iter_value</name>
        <qualifiedname>futures::iter_value</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to <computeroutput>std::iter_value</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/iterator/iter_t"><computeroutput>std::iter_value</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/iter_value.hpp" line="41" column="5" bodyfile="futures/algorithm/traits/iter_value.hpp" bodystart="41" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1gabd912e4dacd864daedb36cd1f39e1723" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>typename <ref refid="group__traits_1gab7bdd46a3627a696302c30934567f51d" kindref="member">iter_value</ref>&lt; T &gt;::type</type>
        <definition>using futures::iter_value_t = typedef typename iter_value&lt;T&gt;::type</definition>
        <argsstring></argsstring>
        <name>iter_value_t</name>
        <qualifiedname>futures::iter_value_t</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to <computeroutput>std::iter_value</computeroutput>   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/iterator/iter_t"><computeroutput>std::iter_value</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/iter_value.hpp" line="61" column="5" bodyfile="futures/algorithm/traits/iter_value.hpp" bodystart="61" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1gaba9b74185a646620729400ed744f7ecc" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::iterator&lt; R &gt;</type>
        <definition>using futures::iterator = typedef std::iterator&lt;R&gt;</definition>
        <argsstring></argsstring>
        <name>iterator</name>
        <qualifiedname>futures::iterator</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::iterator</computeroutput> trait. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/ranges/iterator_t"><computeroutput>std::ranges::iterator_t</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/iterator.hpp" line="42" column="5" bodyfile="futures/algorithm/traits/iterator.hpp" bodystart="42" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1ga25b9349b8a29ca3bea4913f8b704e515" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>typename <ref refid="group__traits_1gaba9b74185a646620729400ed744f7ecc" kindref="member">iterator</ref>&lt; T &gt;::type</type>
        <definition>using futures::iterator_t = typedef typename iterator&lt;T&gt;::type</definition>
        <argsstring></argsstring>
        <name>iterator_t</name>
        <qualifiedname>futures::iterator_t</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::iterator</computeroutput> trait.   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/ranges/iterator_t"><computeroutput>std::ranges::iterator_t</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/iterator.hpp" line="55" column="5" bodyfile="futures/algorithm/traits/iterator.hpp" bodystart="55" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1gaa097d6855d1af3709d4facf9848b3088" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class R</type>
          </param>
        </templateparamlist>
        <type>std::range_value&lt; R &gt;</type>
        <definition>using futures::range_value = typedef std::range_value&lt;R&gt;</definition>
        <argsstring></argsstring>
        <name>range_value</name>
        <qualifiedname>futures::range_value</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to <computeroutput>std::range_value</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/ranges/iterator_t"><computeroutput>std::ranges::iterator_t</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/range_value.hpp" line="41" column="5" bodyfile="futures/algorithm/traits/range_value.hpp" bodystart="41" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1ga36b10fa59d1005a75cecb03df26b12d8" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class R</type>
          </param>
        </templateparamlist>
        <type>typename <ref refid="group__traits_1gaa097d6855d1af3709d4facf9848b3088" kindref="member">range_value</ref>&lt; R &gt;::type</type>
        <definition>using futures::range_value_t = typedef typename range_value&lt;R&gt;::type</definition>
        <argsstring></argsstring>
        <name>range_value_t</name>
        <qualifiedname>futures::range_value_t</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to <computeroutput>std::range_value</computeroutput>   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/ranges/iterator_t"><computeroutput>std::ranges::iterator_t</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/range_value.hpp" line="58" column="5" bodyfile="futures/algorithm/traits/range_value.hpp" bodystart="58" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1gab2f4c9b824ed7e93242a4f61967218df" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::remove_cvref&lt; T &gt;</type>
        <definition>using futures::remove_cvref = typedef std::remove_cvref&lt;T&gt;</definition>
        <argsstring></argsstring>
        <name>remove_cvref</name>
        <qualifiedname>futures::remove_cvref</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to <computeroutput>std::remove_cvref</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/types/remove_cvref"><computeroutput>std::remove_cvref</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/remove_cvref.hpp" line="36" column="5" bodyfile="futures/algorithm/traits/remove_cvref.hpp" bodystart="36" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__traits_1ga08dfd6b7fc387123f45b76f825a47193" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>typename <ref refid="group__traits_1gab2f4c9b824ed7e93242a4f61967218df" kindref="member">remove_cvref</ref>&lt; T &gt;::type</type>
        <definition>using futures::remove_cvref_t = typedef typename remove_cvref&lt;T&gt;::type</definition>
        <argsstring></argsstring>
        <name>remove_cvref_t</name>
        <qualifiedname>futures::remove_cvref_t</qualifiedname>
        <briefdescription>
<para>A type trait equivalent to <computeroutput>std::remove_cvref</computeroutput>   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/types/remove_cvref"><computeroutput>std::remove_cvref</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/remove_cvref.hpp" line="45" column="5" bodyfile="futures/algorithm/traits/remove_cvref.hpp" bodystart="45" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__executors_1gaf961f88543ab12949fd90f310bc90663" prot="public" static="no">
        <type>__see_below__</type>
        <definition>using futures::default_execution_context_type = typedef __see_below__</definition>
        <argsstring></argsstring>
        <name>default_execution_context_type</name>
        <qualifiedname>futures::default_execution_context_type</qualifiedname>
        <briefdescription>
<para>The default execution context for async operations. </para>
        </briefdescription>
        <detaileddescription>
<para>Unless an executor is explicitly provided, this is the executor we use for async operations.</para>
<para>This is the ASIO thread pool execution context with a default number of threads. However, the default execution context (and its type) might change in other versions of this library if something more general comes along. As the standard for executors gets adopted, libraries are likely to provide better implementations.</para>
<para>Also note that executors might not allow work-stealing. This needs to be taken into account when implementing algorithms with recursive tasks. One common options is to use <computeroutput>try_async</computeroutput> for recursive tasks.</para>
<para>Also note that, in the executors notation, the pool is an execution context but not an executor:<itemizedlist>
<listitem><para>Execution context: a place where we can execute functions</para>
</listitem><listitem><para>A thread pool is an execution context, not an executor</para>
</listitem></itemizedlist>
</para>
<para>An execution context is:<itemizedlist>
<listitem><para>Usually long lived</para>
</listitem><listitem><para>Non-copyable</para>
</listitem><listitem><para>May contain additional state, such as timers, and threads </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/executor/default_executor.hpp" line="55" column="5" bodyfile="futures/executor/default_executor.hpp" bodystart="55" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__executors_1gacdecb5da8c06084b542ae33964dba59b" prot="public" static="no">
        <type>default_execution_context_type::executor_type</type>
        <definition>using futures::default_executor_type = typedef default_execution_context_type::executor_type</definition>
        <argsstring></argsstring>
        <name>default_executor_type</name>
        <qualifiedname>futures::default_executor_type</qualifiedname>
        <briefdescription>
<para>Default executor type. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/executor/default_executor.hpp" line="58" column="5" bodyfile="futures/executor/default_executor.hpp" bodystart="58" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__executors_1gad9066c383b30d857c2527720c86f0a71" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class E</type>
          </param>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type>std::bool_constant&lt; execution_context_for&lt; E, F &gt; &gt;</type>
        <definition>using futures::is_execution_context_for = typedef std::bool_constant&lt; execution_context_for&lt;E, F&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_execution_context_for</name>
        <qualifiedname>futures::is_execution_context_for</qualifiedname>
        <briefdescription>
<para>Determine if type is an execution context for the specified type of task. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/executor/is_execution_context.hpp" line="55" column="5" bodyfile="futures/executor/is_execution_context.hpp" bodystart="56" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__executors_1ga50b8774bb35c27e2150e9080a3590038" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class E</type>
          </param>
        </templateparamlist>
        <type>std::bool_constant&lt; execution_context&lt; E &gt; &gt;</type>
        <definition>using futures::is_execution_context = typedef std::bool_constant&lt;execution_context&lt;E&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_execution_context</name>
        <qualifiedname>futures::is_execution_context</qualifiedname>
        <briefdescription>
<para>Determines if a type is an execution context for invocable types. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/executor/is_execution_context.hpp" line="65" column="5" bodyfile="futures/executor/is_execution_context.hpp" bodystart="65" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__executors_1ga6702c04e6873f0a2ce6344a5dd3a60a7" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class E</type>
          </param>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type>std::bool_constant&lt; executor_for&lt; E, F &gt; &gt;</type>
        <definition>using futures::is_executor_for = typedef std::bool_constant&lt;executor_for&lt;E, F&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_executor_for</name>
        <qualifiedname>futures::is_executor_for</qualifiedname>
        <briefdescription>
<para>Determine if type is an executor for the specified type of task. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/executor/is_executor.hpp" line="62" column="5" bodyfile="futures/executor/is_executor.hpp" bodystart="62" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__executors_1gaabcc65b63cd88a8479054d368e688f27" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class E</type>
          </param>
        </templateparamlist>
        <type>std::bool_constant&lt; executor&lt; E &gt; &gt;</type>
        <definition>using futures::is_executor = typedef std::bool_constant&lt;executor&lt;E&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>is_executor</name>
        <qualifiedname>futures::is_executor</qualifiedname>
        <briefdescription>
<para>Determines if a type is an executor for invocable types. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/executor/is_executor.hpp" line="73" column="5" bodyfile="futures/executor/is_executor.hpp" bodystart="73" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__future-options_1ga7f03484ae7db4ae89f95bade537afc35" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>detail::future_options_flat_t&lt; Args... &gt;</type>
        <definition>using futures::future_options = typedef detail::future_options_flat_t&lt;Args...&gt;</definition>
        <argsstring></argsstring>
        <name>future_options</name>
        <qualifiedname>futures::future_options</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/future_options.hpp" line="35" column="5" bodyfile="futures/future_options.hpp" bodystart="35" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__error_1gaa09c7b0f3e466783023afb96eea90fad" prot="public" static="no">
        <type>std::source_location</type>
        <definition>using futures::source_location = typedef std::source_location</definition>
        <argsstring></argsstring>
        <name>source_location</name>
        <qualifiedname>futures::source_location</qualifiedname>
        <briefdescription>
<para>A library type equivalent to <computeroutput>std::source_location</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para>The source_location class represents certain information about the source code, such as file names, line numbers, and function names.</para>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/utility/source_location"><computeroutput>std::source_location</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/throw.hpp" line="45" column="5" bodyfile="futures/throw.hpp" bodystart="45" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__future-traits_1ga6b9f710ec419153132923160875d24ad" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__see_below__</type>
        <definition>using futures::future_value = typedef __see_below__</definition>
        <argsstring></argsstring>
        <name>future_value</name>
        <qualifiedname>futures::future_value</qualifiedname>
        <briefdescription>
<para>Determine type the future object holds. </para>
        </briefdescription>
        <detaileddescription>
<para>Primary template handles non-future types</para>
<para><simplesect kind="note"><para>Not to be confused with continuation unwrapping </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/traits/future_value.hpp" line="39" column="5" bodyfile="futures/traits/future_value.hpp" bodystart="39" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__future-traits_1ga6e31e50532fd1185e4321c4b76918907" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>typename <ref refid="group__future-traits_1ga6b9f710ec419153132923160875d24ad" kindref="member">future_value</ref>&lt; T &gt;::type</type>
        <definition>using futures::future_value_t = typedef typename future_value&lt;T&gt;::type</definition>
        <argsstring></argsstring>
        <name>future_value_t</name>
        <qualifiedname>futures::future_value_t</qualifiedname>
        <briefdescription>
<para>Determine type the future object holds.   </para>
        </briefdescription>
        <detaileddescription>
<para>Primary template handles non-future types</para>
<para><simplesect kind="note"><para>Not to be confused with continuation unwrapping   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/traits/future_value.hpp" line="63" column="5" bodyfile="futures/traits/future_value.hpp" bodystart="63" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__future-traits_1ga721bbb35763f4def43c4360cf80e7363" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__see_below__</type>
        <definition>using futures::has_stop_token = typedef __see_below__</definition>
        <argsstring></argsstring>
        <name>has_stop_token</name>
        <qualifiedname>futures::has_stop_token</qualifiedname>
        <briefdescription>
<para>Customization point to define future as having a common stop token. </para>
        </briefdescription>
        <detaileddescription>
<para>Besides being stoppable, this trait identifies whether the future has a stop token, which means this token can be shared with other futures to create a common thread of futures that can be stopped with the same token.</para>
<para>Unless the trait is specialized, a type is considered to have a stop token if it has the <computeroutput>get_stop_source()</computeroutput> and <computeroutput>get_stop_token()</computeroutput> member functions.</para>
<para><simplesect kind="see"><para><itemizedlist>
<listitem><para>is_stoppable </para>
</listitem>
</itemizedlist>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/traits/has_stop_token.hpp" line="50" column="5" bodyfile="futures/traits/has_stop_token.hpp" bodystart="50" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__future-traits_1ga367eb573176946bd3c564a385eb549fe" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__see_below__</type>
        <definition>using futures::is_stoppable = typedef __see_below__</definition>
        <argsstring></argsstring>
        <name>is_stoppable</name>
        <qualifiedname>futures::is_stoppable</qualifiedname>
        <briefdescription>
<para>Customization point to define future as stoppable. </para>
        </briefdescription>
        <detaileddescription>
<para>This trait identifies whether the future is stoppable, which means the future has a <computeroutput>request_stop</computeroutput> function to stop the underlying task.</para>
<para><simplesect kind="note"><para>Not all stoppable futures have stops token, which can be shared with other futures to create a common thread of futures that can be stopped with the same token.</para>
</simplesect>
Unless the trait is specialized, a type is considered stoppable if it has the <computeroutput>request_stop()</computeroutput> member function.</para>
<para><simplesect kind="see"><para><itemizedlist>
<listitem><para>has_stop_token </para>
</listitem>
</itemizedlist>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/traits/is_stoppable.hpp" line="50" column="5" bodyfile="futures/traits/is_stoppable.hpp" bodystart="50" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="var">
      <memberdef kind="variable" id="group__functions_1ga0a19ce4d22f4c8a251aced2077623b03" prot="public" static="no" constexpr="yes" mutable="no">
        <type>constexpr <ref refid="classfutures_1_1all__of__functor" kindref="compound">all_of_functor</ref></type>
        <definition>constexpr all_of_functor futures::all_of</definition>
        <argsstring></argsstring>
        <name>all_of</name>
        <qualifiedname>futures::all_of</qualifiedname>
        <briefdescription>
<para>Checks if a predicate is true for all the elements in a range. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/all_of.hpp" line="176" column="39" bodyfile="futures/algorithm/all_of.hpp" bodystart="176" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__functions_1gac70d945839135728f9ac534f5a8626c9" prot="public" static="no" constexpr="yes" mutable="no">
        <type>constexpr <ref refid="classfutures_1_1any__of__functor" kindref="compound">any_of_functor</ref></type>
        <definition>constexpr any_of_functor futures::any_of</definition>
        <argsstring></argsstring>
        <name>any_of</name>
        <qualifiedname>futures::any_of</qualifiedname>
        <briefdescription>
<para>Checks if a predicate is true for any of the elements in a range. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/any_of.hpp" line="165" column="39" bodyfile="futures/algorithm/any_of.hpp" bodystart="165" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__functions_1gaeb543fc7a0437fc057e2acf823abbb13" prot="public" static="no" constexpr="yes" mutable="no">
        <type>constexpr <ref refid="classfutures_1_1count__functor" kindref="compound">count_functor</ref></type>
        <definition>constexpr count_functor futures::count</definition>
        <argsstring></argsstring>
        <name>count</name>
        <qualifiedname>futures::count</qualifiedname>
        <briefdescription>
<para>Returns the number of elements matching an element. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/count.hpp" line="101" column="38" bodyfile="futures/algorithm/count.hpp" bodystart="101" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__functions_1ga0741d870e77e49d34e7daae10ecfb721" prot="public" static="no" constexpr="yes" mutable="no">
        <type>constexpr <ref refid="classfutures_1_1count__if__functor" kindref="compound">count_if_functor</ref></type>
        <definition>constexpr count_if_functor futures::count_if</definition>
        <argsstring></argsstring>
        <name>count_if</name>
        <qualifiedname>futures::count_if</qualifiedname>
        <briefdescription>
<para>Returns the number of elements satisfying specific criteria. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/count_if.hpp" line="172" column="41" bodyfile="futures/algorithm/count_if.hpp" bodystart="172" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__functions_1ga15c434fa0fbabddf6b1ab8cf06760ec5" prot="public" static="no" constexpr="yes" mutable="no">
        <type>constexpr <ref refid="classfutures_1_1find__functor" kindref="compound">find_functor</ref></type>
        <definition>constexpr find_functor futures::find</definition>
        <argsstring></argsstring>
        <name>find</name>
        <qualifiedname>futures::find</qualifiedname>
        <briefdescription>
<para>Finds the first element equal to another element. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/find.hpp" line="71" column="37" bodyfile="futures/algorithm/find.hpp" bodystart="71" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__functions_1ga10dff629b2c06c53c69024821bce5efc" prot="public" static="no" constexpr="yes" mutable="no">
        <type>constexpr <ref refid="classfutures_1_1find__if__functor" kindref="compound">find_if_functor</ref></type>
        <definition>constexpr find_if_functor futures::find_if</definition>
        <argsstring></argsstring>
        <name>find_if</name>
        <qualifiedname>futures::find_if</qualifiedname>
        <briefdescription>
<para>Finds the first element satisfying specific criteria. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/find_if.hpp" line="234" column="40" bodyfile="futures/algorithm/find_if.hpp" bodystart="234" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__functions_1ga58db85c74ede4cc40c6e8735e3f228d7" prot="public" static="no" constexpr="yes" mutable="no">
        <type>constexpr <ref refid="classfutures_1_1find__if__not__functor" kindref="compound">find_if_not_functor</ref></type>
        <definition>constexpr find_if_not_functor futures::find_if_not</definition>
        <argsstring></argsstring>
        <name>find_if_not</name>
        <qualifiedname>futures::find_if_not</qualifiedname>
        <briefdescription>
<para>Finds the first element not satisfying specific criteria. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/find_if_not.hpp" line="94" column="44" bodyfile="futures/algorithm/find_if_not.hpp" bodystart="94" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__functions_1ga696ae412208d98f074d3ed6667e1a64f" prot="public" static="no" constexpr="yes" mutable="no">
        <type>constexpr <ref refid="classfutures_1_1for__each__functor" kindref="compound">for_each_functor</ref></type>
        <definition>constexpr for_each_functor futures::for_each</definition>
        <argsstring></argsstring>
        <name>for_each</name>
        <qualifiedname>futures::for_each</qualifiedname>
        <briefdescription>
<para>Applies a function to a range of elements. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/for_each.hpp" line="180" column="41" bodyfile="futures/algorithm/for_each.hpp" bodystart="180" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__functions_1ga0fb3a8de3d488915fcd3ebe63d603731" prot="public" static="no" constexpr="yes" mutable="no">
        <type>constexpr <ref refid="classfutures_1_1none__of__functor" kindref="compound">none_of_functor</ref></type>
        <definition>constexpr none_of_functor futures::none_of</definition>
        <argsstring></argsstring>
        <name>none_of</name>
        <qualifiedname>futures::none_of</qualifiedname>
        <briefdescription>
<para>Checks if a predicate is true for none of the elements in a range. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/none_of.hpp" line="170" column="40" bodyfile="futures/algorithm/none_of.hpp" bodystart="170" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__partitioners_1gac228eb71c167a6df66aa61d19253993d" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class P</type>
          </param>
          <param>
            <type>class I</type>
          </param>
          <param>
            <type>class S</type>
            <defval>I</defval>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_partitioner_for_v</definition>
        <argsstring></argsstring>
        <name>is_partitioner_for_v</name>
        <qualifiedname>futures::is_partitioner_for_v</qualifiedname>
        <initializer>= <ref refid="group__partitioners_1gace2856b25ae230b1d91b1e1a79267cf5" kindref="member">is_partitioner_for</ref>&lt;P, I, S&gt;::value</initializer>
        <briefdescription>
<para>Determine if P is a valid partitioner for the iterator range [I,S]. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/partitioner/partitioner_for.hpp" line="58" column="20" bodyfile="futures/algorithm/partitioner/partitioner_for.hpp" bodystart="58" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__execution-policies_1gabc55040ea2bc2503075ab0b70004899a" prot="public" static="no" constexpr="yes" mutable="no">
        <type>constexpr <ref refid="group__execution-policies_1gaf5d088ab9052836d3d58c62a02697e26" kindref="member">sequenced_policy</ref></type>
        <definition>constexpr sequenced_policy futures::seq</definition>
        <argsstring></argsstring>
        <name>seq</name>
        <qualifiedname>futures::seq</qualifiedname>
        <initializer>{}</initializer>
        <briefdescription>
<para>Tag used in algorithms for a sequenced_policy. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/policies.hpp" line="91" column="41" bodyfile="futures/algorithm/policies.hpp" bodystart="91" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__execution-policies_1ga15d309529b3196659d901c905bd0bbc6" prot="public" static="no" constexpr="yes" mutable="no">
        <type>constexpr <ref refid="group__execution-policies_1gaeb6a426f21b797b63d6cfd5f1a4585ee" kindref="member">parallel_policy</ref></type>
        <definition>constexpr parallel_policy futures::par</definition>
        <argsstring></argsstring>
        <name>par</name>
        <qualifiedname>futures::par</qualifiedname>
        <initializer>{}</initializer>
        <briefdescription>
<para>Tag used in algorithms for a parallel_policy. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/policies.hpp" line="94" column="40" bodyfile="futures/algorithm/policies.hpp" bodystart="94" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__execution-policies_1ga2dfc04fa043d76435dfc6531db67a93d" prot="public" static="no" constexpr="yes" mutable="no">
        <type>constexpr <ref refid="group__execution-policies_1ga1cfc7e6ec53363f996022ad8282b0cfe" kindref="member">parallel_unsequenced_policy</ref></type>
        <definition>constexpr parallel_unsequenced_policy futures::par_unseq</definition>
        <argsstring></argsstring>
        <name>par_unseq</name>
        <qualifiedname>futures::par_unseq</qualifiedname>
        <initializer>{}</initializer>
        <briefdescription>
<para>Tag used in algorithms for a parallel_unsequenced_policy. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/policies.hpp" line="97" column="52" bodyfile="futures/algorithm/policies.hpp" bodystart="97" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__execution-policies_1ga92c59cac6e6ea17c04b929917c037446" prot="public" static="no" constexpr="yes" mutable="no">
        <type>constexpr <ref refid="group__execution-policies_1gabaa708215fbcb22a94cc04f7ef726059" kindref="member">unsequenced_policy</ref></type>
        <definition>constexpr unsequenced_policy futures::unseq</definition>
        <argsstring></argsstring>
        <name>unseq</name>
        <qualifiedname>futures::unseq</qualifiedname>
        <initializer>{}</initializer>
        <briefdescription>
<para>Tag used in algorithms for an unsequenced_policy. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/policies.hpp" line="100" column="43" bodyfile="futures/algorithm/policies.hpp" bodystart="100" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__execution-policies_1ga91acd0da3465836ab08bfa9ed016d2dd" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_execution_policy_v</definition>
        <argsstring></argsstring>
        <name>is_execution_policy_v</name>
        <qualifiedname>futures::is_execution_policy_v</qualifiedname>
        <initializer>= <ref refid="structfutures_1_1is__execution__policy" kindref="compound">is_execution_policy</ref>&lt;T&gt;::value</initializer>
        <briefdescription>
<para>Determines whether T is a standard or implementation-defined execution policy type.   </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/policies.hpp" line="114" column="29" bodyfile="futures/algorithm/policies.hpp" bodystart="115" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__functions_1ga12eba09a0c6fb20ae5a7f3c561e2b433" prot="public" static="no" constexpr="yes" mutable="no">
        <type>constexpr <ref refid="classfutures_1_1reduce__functor" kindref="compound">reduce_functor</ref></type>
        <definition>constexpr reduce_functor futures::reduce</definition>
        <argsstring></argsstring>
        <name>reduce</name>
        <qualifiedname>futures::reduce</qualifiedname>
        <briefdescription>
<para>Sums up (or accumulate with a custom function) a range of elements, except out of order. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/reduce.hpp" line="162" column="39" bodyfile="futures/algorithm/reduce.hpp" bodystart="162" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__traits_1ga77606ec080e615c4f83c1a737589268d" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class LHS</type>
          </param>
          <param>
            <type>class RHS</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_assignable_from_v</definition>
        <argsstring></argsstring>
        <name>is_assignable_from_v</name>
        <qualifiedname>futures::is_assignable_from_v</qualifiedname>
        <initializer>= <ref refid="group__traits_1ga7bda1c11fe675de42221596af9f0df5f" kindref="member">is_assignable_from</ref>&lt;LHS, RHS&gt;::value</initializer>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::assignable_from</computeroutput> concept.   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/concepts/assignable_from"><computeroutput>std::assignable_from</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_assignable_from.hpp" line="58" column="20" bodyfile="futures/algorithm/traits/is_assignable_from.hpp" bodystart="58" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__traits_1ga53831f07f1d23a5c9575f717bf4c4ce1" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class I</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_bidirectional_iterator_v</definition>
        <argsstring></argsstring>
        <name>is_bidirectional_iterator_v</name>
        <qualifiedname>futures::is_bidirectional_iterator_v</qualifiedname>
        <initializer>= <ref refid="group__traits_1ga76db62394fec337406efe0efe4680339" kindref="member">is_bidirectional_iterator</ref>&lt;
        I&gt;::value</initializer>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::bidirectional_iterator</computeroutput> concept.   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/iterator/bidirectional_iterator"><computeroutput>std::bidirectional_iterator</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_bidirectional_iterator.hpp" line="67" column="20" bodyfile="futures/algorithm/traits/is_bidirectional_iterator.hpp" bodystart="67" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__traits_1ga6c5fc06c5acf15dbbc0e490988e0bbcc" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_constructible_from_v</definition>
        <argsstring></argsstring>
        <name>is_constructible_from_v</name>
        <qualifiedname>futures::is_constructible_from_v</qualifiedname>
        <initializer>= <ref refid="group__traits_1gaa14660ab0fd62ba08cc33db046c7f3b1" kindref="member">is_constructible_from</ref>&lt;T&gt;::value</initializer>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::constructible_from</computeroutput> concept.   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/concepts/constructible_from"><computeroutput>std::constructible_from</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_constructible_from.hpp" line="40" column="20" bodyfile="futures/algorithm/traits/is_constructible_from.hpp" bodystart="40" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__traits_1ga99d9a1bd8e1ab89863224c78b515e4e1" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class From</type>
          </param>
          <param>
            <type>class To</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_convertible_to_v</definition>
        <argsstring></argsstring>
        <name>is_convertible_to_v</name>
        <qualifiedname>futures::is_convertible_to_v</qualifiedname>
        <initializer>= <ref refid="group__traits_1ga478ba461a135cc0e9c291252ec9b2d8f" kindref="member">is_convertible_to</ref>&lt;From, To&gt;::value</initializer>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::convertible_to</computeroutput> concept.   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/concepts/convertible_to"><computeroutput>std::convertible_to</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_convertible_to.hpp" line="56" column="20" bodyfile="futures/algorithm/traits/is_convertible_to.hpp" bodystart="56" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__traits_1ga19bdaf3c43f699426957a966a1d16c37" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_copyable_v</definition>
        <argsstring></argsstring>
        <name>is_copyable_v</name>
        <qualifiedname>futures::is_copyable_v</qualifiedname>
        <initializer>= <ref refid="group__traits_1gafeeb5e8c14faf5518660bbbd61cadf2b" kindref="member">is_copyable</ref>&lt;T&gt;::value</initializer>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::copyable</computeroutput> concept.   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/concepts/copyable"><computeroutput>std::copyable</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_copyable.hpp" line="51" column="20" bodyfile="futures/algorithm/traits/is_copyable.hpp" bodystart="51" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__traits_1ga25c80aeac9b688386b0755fd4f7e2236" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_default_initializable_v</definition>
        <argsstring></argsstring>
        <name>is_default_initializable_v</name>
        <qualifiedname>futures::is_default_initializable_v</qualifiedname>
        <initializer>= <ref refid="group__traits_1gade601510289810972f9caf8e2b4c73fb" kindref="member">is_default_initializable</ref>&lt;
        T&gt;::value</initializer>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::default_initializable</computeroutput> concept.   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/concepts/default_initializable"><computeroutput>std::default_initializable</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_default_initializable.hpp" line="58" column="20" bodyfile="futures/algorithm/traits/is_default_initializable.hpp" bodystart="58" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__traits_1gac0544fcb34d2441bf49ecd2b4165b727" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class Derived</type>
          </param>
          <param>
            <type>class Base</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_derived_from_v</definition>
        <argsstring></argsstring>
        <name>is_derived_from_v</name>
        <qualifiedname>futures::is_derived_from_v</qualifiedname>
        <initializer>= <ref refid="group__traits_1ga1e386f4f05388c302d714c7d1a2c6aa2" kindref="member">is_derived_from</ref>&lt;Derived, Base&gt;::value</initializer>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>derived_from</computeroutput> concept.   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/concepts/derived_from"><computeroutput>std::derived_from</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_derived_from.hpp" line="50" column="20" bodyfile="futures/algorithm/traits/is_derived_from.hpp" bodystart="50" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__traits_1ga8465918081b89b0713376f47aa9e51cf" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_equality_comparable_v</definition>
        <argsstring></argsstring>
        <name>is_equality_comparable_v</name>
        <qualifiedname>futures::is_equality_comparable_v</qualifiedname>
        <initializer>= <ref refid="group__traits_1ga700cff8b3f85ddd38376e54c9ca3e6b8" kindref="member">is_equality_comparable</ref>&lt;T&gt;::value</initializer>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::equality_comparable</computeroutput> concept.   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/concepts/equality_comparable"><computeroutput>std::equality_comparable</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_equality_comparable.hpp" line="52" column="20" bodyfile="futures/algorithm/traits/is_equality_comparable.hpp" bodystart="52" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__traits_1ga5a60f9e666ffd6d75f260a8cd79c4fcb" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_equality_comparable_with_v</definition>
        <argsstring></argsstring>
        <name>is_equality_comparable_with_v</name>
        <qualifiedname>futures::is_equality_comparable_with_v</qualifiedname>
        <initializer>= <ref refid="group__traits_1ga33c9e5b16ea99aea746e3bffa28cc56c" kindref="member">is_equality_comparable_with</ref>&lt;T, U&gt;::value</initializer>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::equality_comparable_with</computeroutput> concept.   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/concepts/equality_comparable_with"><computeroutput>std::equality_comparable_with</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_equality_comparable_with.hpp" line="55" column="20" bodyfile="futures/algorithm/traits/is_equality_comparable_with.hpp" bodystart="56" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__traits_1ga39f0eb89da25215eabcb5b741a1f2f8f" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class I</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_forward_iterator_v</definition>
        <argsstring></argsstring>
        <name>is_forward_iterator_v</name>
        <qualifiedname>futures::is_forward_iterator_v</qualifiedname>
        <initializer>= <ref refid="group__traits_1ga848d84bbb112bc916c2efd34da93a572" kindref="member">is_forward_iterator</ref>&lt;I&gt;::value</initializer>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::forward_iterator</computeroutput> concept.   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/iterator/forward_iterator"><computeroutput>std::forward_iterator</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_forward_iterator.hpp" line="54" column="20" bodyfile="futures/algorithm/traits/is_forward_iterator.hpp" bodystart="54" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__traits_1gab9d3117a9157923b43113f8950b58ea6" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class I</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_incrementable_v</definition>
        <argsstring></argsstring>
        <name>is_incrementable_v</name>
        <qualifiedname>futures::is_incrementable_v</qualifiedname>
        <initializer>= <ref refid="group__traits_1ga33d3975351d7b6285a7e0c8663e96c84" kindref="member">is_incrementable</ref>&lt;I&gt;::value</initializer>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::incrementable</computeroutput> concept.   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/iterator/incrementable"><computeroutput>std::incrementable</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_incrementable.hpp" line="62" column="20" bodyfile="futures/algorithm/traits/is_incrementable.hpp" bodystart="62" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__traits_1ga2ce9de37185584b4cc70508a0c709f72" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class I1</type>
          </param>
          <param>
            <type>class I2</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_indirectly_binary_invocable_v</definition>
        <argsstring></argsstring>
        <name>is_indirectly_binary_invocable_v</name>
        <qualifiedname>futures::is_indirectly_binary_invocable_v</qualifiedname>
        <initializer>= <ref refid="group__traits_1gacec3cf84299f155f1a34a4984c69a8e3" kindref="member">is_indirectly_binary_invocable</ref>&lt;F, I1, I2&gt;::value</initializer>
        <briefdescription>
<para>Determine if a function can be invoke with the value type of both iterators.   </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_indirectly_binary_invocable.hpp" line="61" column="20" bodyfile="futures/algorithm/traits/is_indirectly_binary_invocable.hpp" bodystart="62" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__traits_1ga39b8d413d2e15c20ad26708791d48c96" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_indirectly_readable_v</definition>
        <argsstring></argsstring>
        <name>is_indirectly_readable_v</name>
        <qualifiedname>futures::is_indirectly_readable_v</qualifiedname>
        <initializer>= <ref refid="group__traits_1ga5d997016e1af193a53e63e8d35454110" kindref="member">is_indirectly_readable</ref>&lt;T&gt;::value</initializer>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::indirectly_readable</computeroutput> concept.   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/iterator/indirectly_readable"><computeroutput>std::indirectly_readable</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_indirectly_readable.hpp" line="57" column="20" bodyfile="futures/algorithm/traits/is_indirectly_readable.hpp" bodystart="57" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__traits_1ga035daff7f18105b4ec196371bdeb6d5c" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class I</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_indirectly_unary_invocable_v</definition>
        <argsstring></argsstring>
        <name>is_indirectly_unary_invocable_v</name>
        <qualifiedname>futures::is_indirectly_unary_invocable_v</qualifiedname>
        <initializer>= <ref refid="group__traits_1ga8a78009173a34f27d5d088459b744253" kindref="member">is_indirectly_unary_invocable</ref>&lt;F, I&gt;::value</initializer>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::indirectly_unary_invocable</computeroutput> concept.   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/iterator/indirectly_unary_invocable"><computeroutput>std::indirectly_unary_invocable</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_indirectly_unary_invocable.hpp" line="63" column="20" bodyfile="futures/algorithm/traits/is_indirectly_unary_invocable.hpp" bodystart="64" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__traits_1ga164df25f7613782d753e35e084c236b7" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_input_iterator_v</definition>
        <argsstring></argsstring>
        <name>is_input_iterator_v</name>
        <qualifiedname>futures::is_input_iterator_v</qualifiedname>
        <initializer>= <ref refid="group__traits_1gafdc7cbe83b02548031e1457c533b0413" kindref="member">is_input_iterator</ref>&lt;T&gt;::value</initializer>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::input_iterator</computeroutput> concept.   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/iterator/input_iterator"><computeroutput>std::input_iterator</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_input_iterator.hpp" line="48" column="20" bodyfile="futures/algorithm/traits/is_input_iterator.hpp" bodystart="48" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__traits_1gac5975521439989723185832ac2645166" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_input_or_output_iterator_v</definition>
        <argsstring></argsstring>
        <name>is_input_or_output_iterator_v</name>
        <qualifiedname>futures::is_input_or_output_iterator_v</qualifiedname>
        <initializer>= <ref refid="group__traits_1ga787d4f89658a472119f07b2b0797000f" kindref="member">is_input_or_output_iterator</ref>&lt;
        T&gt;::value</initializer>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::is_input_or_output_iterator</computeroutput> concept.   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/iterator/is_input_or_output_iterator"><computeroutput>std::is_input_or_output_iterator</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_input_or_output_iterator.hpp" line="52" column="20" bodyfile="futures/algorithm/traits/is_input_or_output_iterator.hpp" bodystart="52" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__traits_1gac9784d2e05f3cf8a9f9590f04f123e74" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool constexpr</type>
        <definition>bool constexpr futures::is_input_range_v</definition>
        <argsstring></argsstring>
        <name>is_input_range_v</name>
        <qualifiedname>futures::is_input_range_v</qualifiedname>
        <initializer>= <ref refid="group__traits_1gaf1bf7865ae3e06fd952ef1f861a28f70" kindref="member">is_input_range</ref>&lt;T&gt;::value</initializer>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::input_range</computeroutput> concept.   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/ranges/input_range"><computeroutput>std::ranges::input_range</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_input_range.hpp" line="57" column="20" bodyfile="futures/algorithm/traits/is_input_range.hpp" bodystart="57" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__traits_1ga9900979cf6cb29a928197a494ccfd023" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_movable_v</definition>
        <argsstring></argsstring>
        <name>is_movable_v</name>
        <qualifiedname>futures::is_movable_v</qualifiedname>
        <initializer>= <ref refid="group__traits_1gaf041a0c651e1e59ea18df0e2dc2dc8fe" kindref="member">is_movable</ref>&lt;T&gt;::value</initializer>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::movable</computeroutput> concept.   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/concepts/movable"><computeroutput>std::movable</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_movable.hpp" line="51" column="20" bodyfile="futures/algorithm/traits/is_movable.hpp" bodystart="51" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__traits_1gaaba2a10a79777082f19420c161b7ca40" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_move_constructible_v</definition>
        <argsstring></argsstring>
        <name>is_move_constructible_v</name>
        <qualifiedname>futures::is_move_constructible_v</qualifiedname>
        <initializer>= <ref refid="group__traits_1gae4e9bd33e6ed647165d69f3ece27935d" kindref="member">is_move_constructible</ref>&lt;T&gt;::value</initializer>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::move_constructible</computeroutput> concept.   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/concepts/move_constructible"><computeroutput>std::move_constructible</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_move_constructible.hpp" line="48" column="20" bodyfile="futures/algorithm/traits/is_move_constructible.hpp" bodystart="48" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__traits_1gae9954a411bcf40e3f06c2c24b4b0a6bd" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class I</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_random_access_iterator_v</definition>
        <argsstring></argsstring>
        <name>is_random_access_iterator_v</name>
        <qualifiedname>futures::is_random_access_iterator_v</qualifiedname>
        <initializer>= <ref refid="group__traits_1ga0a68b1cb70778749f176868ea5489453" kindref="member">is_random_access_iterator</ref>&lt;
        I&gt;::value</initializer>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::random_access_iterator</computeroutput> concept.   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/iterator/random_access_iterator"><computeroutput>std::random_access_iterator</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_random_access_iterator.hpp" line="78" column="20" bodyfile="futures/algorithm/traits/is_random_access_iterator.hpp" bodystart="78" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__traits_1ga7a11846e3d86b8f2f049f3e4b9ba0733" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_range_v</definition>
        <argsstring></argsstring>
        <name>is_range_v</name>
        <qualifiedname>futures::is_range_v</qualifiedname>
        <initializer>= <ref refid="group__traits_1gaea08f93eea232d08478c9cc04773e116" kindref="member">is_range</ref>&lt;T&gt;::value</initializer>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::range</computeroutput> concept.   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/ranges/range"><computeroutput>std::ranges::range</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_range.hpp" line="56" column="20" bodyfile="futures/algorithm/traits/is_range.hpp" bodystart="56" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__traits_1gaaa5f05191e3a4aaf4b084d1c29559bc4" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_regular_v</definition>
        <argsstring></argsstring>
        <name>is_regular_v</name>
        <qualifiedname>futures::is_regular_v</qualifiedname>
        <initializer>= <ref refid="group__traits_1ga6c651460b5dfa33f143fef4514c3120b" kindref="member">is_regular</ref>&lt;T&gt;::value</initializer>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::regular</computeroutput> concept.   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/concepts/regular"><computeroutput>std::regular</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_regular.hpp" line="48" column="20" bodyfile="futures/algorithm/traits/is_regular.hpp" bodystart="48" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__traits_1gadcef95d15ae7d9498b6c45d0f05bc648" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_semiregular_v</definition>
        <argsstring></argsstring>
        <name>is_semiregular_v</name>
        <qualifiedname>futures::is_semiregular_v</qualifiedname>
        <initializer>= <ref refid="group__traits_1ga1f7dc3c45de0abcd0e466f853e283679" kindref="member">is_semiregular</ref>&lt;T&gt;::value</initializer>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::semiregular</computeroutput> concept.   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/concepts/semiregular"><computeroutput>std::semiregular</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_semiregular.hpp" line="46" column="20" bodyfile="futures/algorithm/traits/is_semiregular.hpp" bodystart="46" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__traits_1gacadf25f8f6492d3710eb2d513b0dc7a7" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class S</type>
          </param>
          <param>
            <type>class I</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_sentinel_for_v</definition>
        <argsstring></argsstring>
        <name>is_sentinel_for_v</name>
        <qualifiedname>futures::is_sentinel_for_v</qualifiedname>
        <initializer>= <ref refid="group__traits_1ga5dea935029d8615e75f76c5d244f1a46" kindref="member">is_sentinel_for</ref>&lt;S, I&gt;::value</initializer>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::sentinel_for</computeroutput> concept.   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/iterator/sentinel_for"><computeroutput>std::sentinel_for</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_sentinel_for.hpp" line="47" column="20" bodyfile="futures/algorithm/traits/is_sentinel_for.hpp" bodystart="47" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__traits_1ga3df986359d7ffe87ad775677e9e46326" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_swappable_v</definition>
        <argsstring></argsstring>
        <name>is_swappable_v</name>
        <qualifiedname>futures::is_swappable_v</qualifiedname>
        <initializer>= <ref refid="group__traits_1gaced3438d14261ee82a0efa2cff8a08e4" kindref="member">is_swappable</ref>&lt;T&gt;::value</initializer>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::swappable</computeroutput> concept.   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/concepts/swappable"><computeroutput>std::swappable</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_swappable.hpp" line="54" column="20" bodyfile="futures/algorithm/traits/is_swappable.hpp" bodystart="54" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__traits_1ga7f63cfc0969c7768a3ed2fb040a99b95" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class Cat</type>
            <defval>partial_ordering</defval>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_three_way_comparable_v</definition>
        <argsstring></argsstring>
        <name>is_three_way_comparable_v</name>
        <qualifiedname>futures::is_three_way_comparable_v</qualifiedname>
        <initializer>= <ref refid="group__traits_1gac22a6b82a79830ec1177653c62c89597" kindref="member">is_three_way_comparable</ref>&lt;T&gt;::value</initializer>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::equality_comparable</computeroutput> concept.   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/utility/compare/three_way_comparable"><computeroutput>std::three_way_comparable</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_three_way_comparable.hpp" line="59" column="20" bodyfile="futures/algorithm/traits/is_three_way_comparable.hpp" bodystart="59" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__traits_1ga8830992102877a3f25d09866d080333f" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_three_way_comparable_with_v</definition>
        <argsstring></argsstring>
        <name>is_three_way_comparable_with_v</name>
        <qualifiedname>futures::is_three_way_comparable_with_v</qualifiedname>
        <initializer>= <ref refid="group__traits_1ga7d342b63b24fa9b3a399a8be75a909b1" kindref="member">is_three_way_comparable_with</ref>&lt;T, U&gt;::value</initializer>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::equality_comparable_with</computeroutput> concept.   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/utility/compare/three_way_comparable"><computeroutput>std::three_way_comparable</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_three_way_comparable_with.hpp" line="59" column="20" bodyfile="futures/algorithm/traits/is_three_way_comparable_with.hpp" bodystart="60" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__traits_1ga7f013c84366d4939cbdbf3f4fd088e09" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_totally_ordered_v</definition>
        <argsstring></argsstring>
        <name>is_totally_ordered_v</name>
        <qualifiedname>futures::is_totally_ordered_v</qualifiedname>
        <initializer>= <ref refid="group__traits_1gacca0150c5cccef1847a596ff7dbfb85c" kindref="member">is_totally_ordered</ref>&lt;T&gt;::value</initializer>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::totally_ordered</computeroutput> concept.   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/concepts/totally_ordered"><computeroutput>std::totally_ordered</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_totally_ordered.hpp" line="53" column="20" bodyfile="futures/algorithm/traits/is_totally_ordered.hpp" bodystart="53" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__traits_1gafa9051526c36ea222da0f4d83f3d3b66" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_totally_ordered_with_v</definition>
        <argsstring></argsstring>
        <name>is_totally_ordered_with_v</name>
        <qualifiedname>futures::is_totally_ordered_with_v</qualifiedname>
        <initializer>= <ref refid="group__traits_1ga3e7a594dd861beb0287aab525b8d44d8" kindref="member">is_totally_ordered_with</ref>&lt;T, U&gt;::
        value</initializer>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::totally_ordered_with</computeroutput> concept.   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/concepts/totally_ordered"><computeroutput>std::totally_ordered</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_totally_ordered_with.hpp" line="54" column="20" bodyfile="futures/algorithm/traits/is_totally_ordered_with.hpp" bodystart="54" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__traits_1gaa514a224bede48a6941ec53d58b3692f" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class I</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_weakly_incrementable_v</definition>
        <argsstring></argsstring>
        <name>is_weakly_incrementable_v</name>
        <qualifiedname>futures::is_weakly_incrementable_v</qualifiedname>
        <initializer>= <ref refid="group__traits_1ga9420a5b6af74d0339ded7b71b49aae5c" kindref="member">is_weakly_incrementable</ref>&lt;I&gt;::value</initializer>
        <briefdescription>
<para>A type trait equivalent to the <computeroutput>std::weakly_incrementable</computeroutput> concept.   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/iterator/weakly_incrementable"><computeroutput>std::weakly_incrementable</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/traits/is_weakly_incrementable.hpp" line="64" column="20" bodyfile="futures/algorithm/traits/is_weakly_incrementable.hpp" bodystart="64" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__executors_1ga1ce8960b0f1aeaf6f5d9c1a08291041d" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class E</type>
          </param>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_execution_context_for_v</definition>
        <argsstring></argsstring>
        <name>is_execution_context_for_v</name>
        <qualifiedname>futures::is_execution_context_for_v</qualifiedname>
        <initializer>= execution_context_for&lt;E, F&gt;</initializer>
        <briefdescription>
<para>Determine if type is an execution context for the specified type of task.   </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/executor/is_execution_context.hpp" line="75" column="20" bodyfile="futures/executor/is_execution_context.hpp" bodystart="75" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__executors_1ga7a06e7d040be2e43b5ae92f8b754133b" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class E</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_execution_context_v</definition>
        <argsstring></argsstring>
        <name>is_execution_context_v</name>
        <qualifiedname>futures::is_execution_context_v</qualifiedname>
        <initializer>= execution_context&lt;E&gt;</initializer>
        <briefdescription>
<para>Determines if a type is an execution context for invocable types.   </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/executor/is_execution_context.hpp" line="85" column="20" bodyfile="futures/executor/is_execution_context.hpp" bodystart="85" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__executors_1ga29e93e53607e1d7fd42078006e8d2155" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class E</type>
          </param>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_executor_for_v</definition>
        <argsstring></argsstring>
        <name>is_executor_for_v</name>
        <qualifiedname>futures::is_executor_for_v</qualifiedname>
        <initializer>= executor_for&lt;E, F&gt;</initializer>
        <briefdescription>
<para>Determine if type is an executor for the specified type of task.   </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/executor/is_executor.hpp" line="82" column="20" bodyfile="futures/executor/is_executor.hpp" bodystart="82" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__executors_1ga27c20c657a0f5357f9523df487980a88" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class E</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_executor_v</definition>
        <argsstring></argsstring>
        <name>is_executor_v</name>
        <qualifiedname>futures::is_executor_v</qualifiedname>
        <initializer>= executor&lt;E&gt;</initializer>
        <briefdescription>
<para>Determines if a type is an executor for invocable types.   </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/executor/is_executor.hpp" line="91" column="20" bodyfile="futures/executor/is_executor.hpp" bodystart="91" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__cancellation_1ga01213ebdf9bd19b06e4860d863094735" prot="public" static="no" constexpr="yes" mutable="no">
        <type>constexpr <ref refid="structfutures_1_1nostopstate__t" kindref="compound">nostopstate_t</ref></type>
        <definition>constexpr nostopstate_t futures::nostopstate</definition>
        <argsstring></argsstring>
        <name>nostopstate</name>
        <qualifiedname>futures::nostopstate</qualifiedname>
        <initializer>{}</initializer>
        <briefdescription>
<para>Empty struct to initialize a <ref refid="classfutures_1_1stop__source" kindref="compound">stop_source</ref> without a shared stop state. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/stop_token.hpp" line="66" column="38" bodyfile="futures/stop_token.hpp" bodystart="66" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__future-traits_1ga1d65f925849576acd6b5a4a6333d1380" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::has_executor_v</definition>
        <argsstring></argsstring>
        <name>has_executor_v</name>
        <qualifiedname>futures::has_executor_v</qualifiedname>
        <initializer>= <ref refid="structfutures_1_1has__executor" kindref="compound">has_executor</ref>&lt;T&gt;::value</initializer>
        <briefdescription>
<para>Determine if a future type has an executor.   </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/traits/has_executor.hpp" line="38" column="20" bodyfile="futures/traits/has_executor.hpp" bodystart="38" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__future-traits_1gaaa06f944510ee5b88b996ec9e1f41adb" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::has_ready_notifier_v</definition>
        <argsstring></argsstring>
        <name>has_ready_notifier_v</name>
        <qualifiedname>futures::has_ready_notifier_v</qualifiedname>
        <initializer>= <ref refid="structfutures_1_1has__ready__notifier" kindref="compound">has_ready_notifier</ref>&lt;T&gt;::value</initializer>
        <briefdescription>
<para>Customization point to determine if a type has a ready notifier.   </para>
        </briefdescription>
        <detaileddescription>
<para>The ready notifier is an external handle used to identify when the future is ready.   </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/traits/has_ready_notifier.hpp" line="42" column="20" bodyfile="futures/traits/has_ready_notifier.hpp" bodystart="42" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__future-traits_1ga298d5e966d0a87153c8feb6dfaf6a222" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::has_stop_token_v</definition>
        <argsstring></argsstring>
        <name>has_stop_token_v</name>
        <qualifiedname>futures::has_stop_token_v</qualifiedname>
        <initializer>= <ref refid="group__future-traits_1ga721bbb35763f4def43c4360cf80e7363" kindref="member">has_stop_token</ref>&lt;T&gt;::value</initializer>
        <briefdescription>
<para>Customization point to define future as having a common stop token.   </para>
        </briefdescription>
        <detaileddescription>
<para>Besides being stoppable, this trait identifies whether the future has a stop token, which means this token can be shared with other futures to create a common thread of futures that can be stopped with the same token.</para>
<para>Unless the trait is specialized, a type is considered to have a stop token if it has the <computeroutput>get_stop_source()</computeroutput> and <computeroutput>get_stop_token()</computeroutput> member functions.</para>
<para><simplesect kind="see"><para><itemizedlist>
<listitem><para>is_stoppable   </para>
</listitem>
</itemizedlist>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/traits/has_stop_token.hpp" line="72" column="20" bodyfile="futures/traits/has_stop_token.hpp" bodystart="72" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__future-traits_1ga61c743647bbfe6907f93a674af321ad1" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_always_deferred_v</definition>
        <argsstring></argsstring>
        <name>is_always_deferred_v</name>
        <qualifiedname>futures::is_always_deferred_v</qualifiedname>
        <initializer>= <ref refid="structfutures_1_1is__always__deferred" kindref="compound">is_always_deferred</ref>&lt;T&gt;::value</initializer>
        <briefdescription>
<para>Customization point to define future as always deferred. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/traits/is_always_deferred.hpp" line="47" column="20" bodyfile="futures/traits/is_always_deferred.hpp" bodystart="47" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__future-traits_1gaa1dab24425678e965a56ff21c6d1624e" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_continuable_v</definition>
        <argsstring></argsstring>
        <name>is_continuable_v</name>
        <qualifiedname>futures::is_continuable_v</qualifiedname>
        <initializer>= <ref refid="structfutures_1_1is__continuable" kindref="compound">is_continuable</ref>&lt;T&gt;::value</initializer>
        <briefdescription>
<para>Customization point to define future as supporting continuations.   </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/traits/is_continuable.hpp" line="38" column="20" bodyfile="futures/traits/is_continuable.hpp" bodystart="38" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__future-traits_1gaafc70e30ead3e35866fa26ba79b3721d" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_future_like_v</definition>
        <argsstring></argsstring>
        <name>is_future_like_v</name>
        <qualifiedname>futures::is_future_like_v</qualifiedname>
        <initializer>= <ref refid="structfutures_1_1is__future__like" kindref="compound">is_future_like</ref>&lt;T&gt;::value</initializer>
        <briefdescription>
<para>Customization point to determine if a type is a future type.   </para>
        </briefdescription>
        <detaileddescription>
<para>This trait identifies whether the type represents a future value.</para>
<para>Unless the trait is specialized, a type is considered future-like if it has the <computeroutput>get()</computeroutput> member function.</para>
<para><simplesect kind="see"><para><itemizedlist>
<listitem><para>has_stop_token   </para>
</listitem>
</itemizedlist>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/traits/is_future_like.hpp" line="74" column="20" bodyfile="futures/traits/is_future_like.hpp" bodystart="74" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__future-traits_1ga98d13b2d7d89edd37c377b59e2c3d6f5" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_shared_future_v</definition>
        <argsstring></argsstring>
        <name>is_shared_future_v</name>
        <qualifiedname>futures::is_shared_future_v</qualifiedname>
        <initializer>= <ref refid="structfutures_1_1is__shared__future" kindref="compound">is_shared_future</ref>&lt;T&gt;::value</initializer>
        <briefdescription>
<para>Customization point to determine if a type is a shared future type.   </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/traits/is_shared_future.hpp" line="38" column="20" bodyfile="futures/traits/is_shared_future.hpp" bodystart="38" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__future-traits_1gad4b42cfc7fecf09378dbf1548501a366" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool futures::is_stoppable_v</definition>
        <argsstring></argsstring>
        <name>is_stoppable_v</name>
        <qualifiedname>futures::is_stoppable_v</qualifiedname>
        <initializer>= <ref refid="group__future-traits_1ga367eb573176946bd3c564a385eb549fe" kindref="member">is_stoppable</ref>&lt;T&gt;::value</initializer>
        <briefdescription>
<para>Customization point to define future as stoppable.   </para>
        </briefdescription>
        <detaileddescription>
<para>This trait identifies whether the future is stoppable, which means the future has a <computeroutput>request_stop</computeroutput> function to stop the underlying task.</para>
<para><simplesect kind="note"><para>Not all stoppable futures have stops token, which can be shared with other futures to create a common thread of futures that can be stopped with the same token.</para>
</simplesect>
Unless the trait is specialized, a type is considered stoppable if it has the <computeroutput>request_stop()</computeroutput> member function.</para>
<para><simplesect kind="see"><para><itemizedlist>
<listitem><para>has_stop_token   </para>
</listitem>
</itemizedlist>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/traits/is_stoppable.hpp" line="72" column="20" bodyfile="futures/traits/is_stoppable.hpp" bodystart="72" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__adaptors_1ga3d79a1bc16752e3a3b2d9cda6904178c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>executor</type>
            <declname>Executor</declname>
            <defname>Executor</defname>
          </param>
          <param>
            <type>class Function</type>
          </param>
        </templateparamlist>
        <type>__see_below__</type>
        <definition>__see_below__ futures::operator%</definition>
        <argsstring>(Executor const &amp;ex, Function &amp;&amp;after)</argsstring>
        <name>operator%</name>
        <qualifiedname>futures::operator%</qualifiedname>
        <param>
          <type>Executor const &amp;</type>
          <declname>ex</declname>
        </param>
        <param>
          <type>Function &amp;&amp;</type>
          <declname>after</declname>
        </param>
    <requiresclause>detail::is_callable_v&lt;std::decay_t&lt;Function&gt;&gt;    </requiresclause>
        <briefdescription>
<para>Create a proxy pair with a lambda and an executor. </para>
        </briefdescription>
        <detaileddescription>
<para>For this operation, we needed an operator with higher precedence than operator&gt;&gt; Our options are: +, -, *, /, %, &amp;, !, ~. Although + seems like an obvious choice, % is the one that leads to less conflict with other functions.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ex</parametername>
</parameternamelist>
<parameterdescription>
<para>An executor </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>after</parametername>
</parameternamelist>
<parameterdescription>
<para>A callable with the continuation </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A proxy pair to schedule execution </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/adaptor/bind_executor_to_lambda.hpp" line="85" column="5" bodyfile="futures/adaptor/bind_executor_to_lambda.hpp" bodystart="85" bodyend="93"/>
      </memberdef>
      <memberdef kind="function" id="group__adaptors_1gacb4e00b6c170bb3ae76893524bfab046" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classfutures_1_1basic__future" kindref="compound">basic_future</ref>&lt; void, <ref refid="group__future-options_1ga7f03484ae7db4ae89f95bade537afc35" kindref="member">future_options</ref>&lt;&gt; &gt;</type>
        <definition>basic_future&lt; void, future_options&lt;&gt; &gt; futures::make_ready_future</definition>
        <argsstring>()</argsstring>
        <name>make_ready_future</name>
        <qualifiedname>futures::make_ready_future</qualifiedname>
        <briefdescription>
<para>Make a placeholder future object that is ready at construction. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>A future associated with the shared state that is created.</para>
</simplesect>
<simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/experimental/make_ready_future"><computeroutput>std::experimental::make_ready_future</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/adaptor/make_ready_future.hpp" line="33" column="5" bodyfile="futures/adaptor/make_ready_future.hpp" bodystart="33" bodyend="35"/>
      </memberdef>
      <memberdef kind="function" id="group__adaptors_1ga659e9f6c7e24219433bf4079ada8e2b3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classfutures_1_1basic__future" kindref="compound">basic_future</ref>&lt; typename std::decay_t&lt; T &gt;, <ref refid="group__future-options_1ga7f03484ae7db4ae89f95bade537afc35" kindref="member">future_options</ref>&lt;&gt; &gt;</type>
        <definition>basic_future&lt; typename std::decay_t&lt; T &gt;, future_options&lt;&gt; &gt; futures::make_ready_future</definition>
        <argsstring>(T &amp;&amp;value)</argsstring>
        <name>make_ready_future</name>
        <qualifiedname>futures::make_ready_future</qualifiedname>
        <param>
          <type>T &amp;&amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Make a placeholder future object that is ready at construction.   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>A future associated with the shared state that is created.</para>
</simplesect>
<simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/experimental/make_ready_future"><computeroutput>std::experimental::make_ready_future</computeroutput></ulink>   </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>The value for the new future </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/adaptor/make_ready_future.hpp" line="43" column="5" bodyfile="futures/adaptor/make_ready_future.hpp" bodystart="43" bodyend="46"/>
      </memberdef>
      <memberdef kind="function" id="group__adaptors_1ga0e4df3e1f8048b61db143fdd7d29b9c7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classfutures_1_1basic__future" kindref="compound">basic_future</ref>&lt; T &amp;, <ref refid="group__future-options_1ga7f03484ae7db4ae89f95bade537afc35" kindref="member">future_options</ref>&lt;&gt; &gt;</type>
        <definition>basic_future&lt; T &amp;, future_options&lt;&gt; &gt; futures::make_ready_future</definition>
        <argsstring>(std::reference_wrapper&lt; T &gt; value)</argsstring>
        <name>make_ready_future</name>
        <qualifiedname>futures::make_ready_future</qualifiedname>
        <param>
          <type>std::reference_wrapper&lt; T &gt;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Make a placeholder future object that is ready at construction.   </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>A future associated with the shared state that is created.</para>
</simplesect>
<simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/experimental/make_ready_future"><computeroutput>std::experimental::make_ready_future</computeroutput></ulink>   </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>The value for the new future </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/adaptor/make_ready_future.hpp" line="54" column="5" bodyfile="futures/adaptor/make_ready_future.hpp" bodystart="54" bodyend="57"/>
      </memberdef>
      <memberdef kind="function" id="group__adaptors_1gab5ece643ec44101cce6bd81b2fb84966" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
            <defval>void</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classfutures_1_1basic__future" kindref="compound">basic_future</ref>&lt; T, <ref refid="group__future-options_1ga7f03484ae7db4ae89f95bade537afc35" kindref="member">future_options</ref>&lt;&gt; &gt;</type>
        <definition>basic_future&lt; T, future_options&lt;&gt; &gt; futures::make_exceptional_future</definition>
        <argsstring>(std::exception_ptr ex)</argsstring>
        <name>make_exceptional_future</name>
        <qualifiedname>futures::make_exceptional_future</qualifiedname>
        <param>
          <type>std::exception_ptr</type>
          <declname>ex</declname>
        </param>
        <briefdescription>
<para>Make a placeholder future object that is ready with an exception from an exception ptr. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ex</parametername>
</parameternamelist>
<parameterdescription>
<para>The exception for the new future </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A future associated with the shared state that is created.</para>
</simplesect>
<simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/experimental/make_exceptional_future"><computeroutput>std::experimental::make_exceptional_future</computeroutput></ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/adaptor/make_ready_future.hpp" line="71" column="5" bodyfile="futures/adaptor/make_ready_future.hpp" bodystart="71" bodyend="74"/>
      </memberdef>
      <memberdef kind="function" id="group__adaptors_1ga512555b53d37358d770df8df97e4e398" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
            <defval>void</defval>
          </param>
          <param>
            <type>class E</type>
          </param>
        </templateparamlist>
        <type><ref refid="classfutures_1_1basic__future" kindref="compound">basic_future</ref>&lt; T, <ref refid="group__future-options_1ga7f03484ae7db4ae89f95bade537afc35" kindref="member">future_options</ref>&lt;&gt; &gt;</type>
        <definition>basic_future&lt; T, future_options&lt;&gt; &gt; futures::make_exceptional_future</definition>
        <argsstring>(E ex)</argsstring>
        <name>make_exceptional_future</name>
        <qualifiedname>futures::make_exceptional_future</qualifiedname>
        <param>
          <type>E</type>
          <declname>ex</declname>
        </param>
        <briefdescription>
<para>Make a placeholder future object that is ready with an exception from an exception ptr.   </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ex</parametername>
</parameternamelist>
<parameterdescription>
<para>The exception for the new future </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A future associated with the shared state that is created.</para>
</simplesect>
<simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/experimental/make_exceptional_future"><computeroutput>std::experimental::make_exceptional_future</computeroutput></ulink>   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/adaptor/make_ready_future.hpp" line="79" column="5" bodyfile="futures/adaptor/make_ready_future.hpp" bodystart="79" bodyend="82"/>
      </memberdef>
      <memberdef kind="function" id="group__adaptors_1ga4bc04aed0af78c914f202a2ccad236a0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>future_like</type>
            <declname>Future</declname>
            <defname>Future</defname>
          </param>
          <param>
            <type>class Function</type>
          </param>
        </templateparamlist>
        <type>__see_below__</type>
        <definition>__see_below__ futures::then</definition>
        <argsstring>(Future &amp;&amp;before, Function &amp;&amp;after)</argsstring>
        <name>then</name>
        <qualifiedname>futures::then</qualifiedname>
        <param>
          <type>Future &amp;&amp;</type>
          <declname>before</declname>
        </param>
        <param>
          <type>Function &amp;&amp;</type>
          <declname>after</declname>
        </param>
    <requiresclause>( !is_executor_v&lt;std::decay_t&lt;Function&gt;&gt; &amp;&amp; !is_executor_v&lt;std::decay_t&lt;Future&gt;&gt; &amp;&amp; detail::next_future_traits&lt; default_executor_type, std::decay_t&lt;Function&gt;, std::decay_t&lt;Future&gt;&gt;::is_valid)    </requiresclause>
        <briefdescription>
<para>Schedule a continuation function to a future. </para>
        </briefdescription>
        <detaileddescription>
<para>This function creates a continuation that gets executed when the <computeroutput>before</computeroutput> future is completed. The continuation needs to be invocable with the return type of the previous future.</para>
<para>This function works for all kinds of futures but behavior depends on the input:<itemizedlist>
<listitem><para>If the previous future is continuable, attach the function to the continuation list</para>
</listitem><listitem><para>If the previous future is not continuable (such as std::future), post to execution with deferred policy. In both cases, the result becomes a cfuture or jcfuture.</para>
</listitem></itemizedlist>
</para>
<para>Stop tokens are also propagated:<itemizedlist>
<listitem><para>If after function expects a stop token:<itemizedlist>
<listitem><para>If previous future is stoppable and not-shared: return jcfuture with shared stop source</para>
</listitem><listitem><para>Otherwise: return jcfuture with new stop source</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para>If after function does not expect a stop token:<itemizedlist>
<listitem><para>If previous future is stoppable and not-shared: return jcfuture with shared stop source</para>
</listitem><listitem><para>Otherwise: return cfuture with no stop source</para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>before</parametername>
</parameternamelist>
<parameterdescription>
<para>The antecedent future </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>after</parametername>
</parameternamelist>
<parameterdescription>
<para>The continuation callable </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A continuation to the before future </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/adaptor/then.hpp" line="115" column="19" bodyfile="futures/adaptor/then.hpp" bodystart="115" bodyend="120"/>
      </memberdef>
      <memberdef kind="function" id="group__adaptors_1ga3c5bcb86d6f7a938f4d1dea57dcfae0c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>executor</type>
            <declname>Executor</declname>
            <defname>Executor</defname>
          </param>
          <param>
            <type>class Function</type>
          </param>
          <param>
            <type>class Future</type>
          </param>
        </templateparamlist>
        <type>__see_below__</type>
        <definition>__see_below__ futures::then</definition>
        <argsstring>(Executor const &amp;ex, Future &amp;&amp;before, Function &amp;&amp;after)</argsstring>
        <name>then</name>
        <qualifiedname>futures::then</qualifiedname>
        <param>
          <type>Executor const &amp;</type>
          <declname>ex</declname>
        </param>
        <param>
          <type>Future &amp;&amp;</type>
          <declname>before</declname>
        </param>
        <param>
          <type>Function &amp;&amp;</type>
          <declname>after</declname>
        </param>
    <requiresclause>( !is_executor_v&lt;std::decay_t&lt;Function&gt;&gt; &amp;&amp; !is_executor_v&lt;std::decay_t&lt;Future&gt;&gt; &amp;&amp; is_future_like_v&lt;std::decay_t&lt;Future&gt;&gt; &amp;&amp; detail::next_future_traits&lt; Executor, std::decay_t&lt;Function&gt;, std::decay_t&lt;Future&gt;&gt;::is_valid)    </requiresclause>
        <briefdescription>
<para>Schedule a continuation function to a future.   </para>
        </briefdescription>
        <detaileddescription>
<para>This function creates a continuation that gets executed when the <computeroutput>before</computeroutput> future is completed. The continuation needs to be invocable with the return type of the previous future.</para>
<para>This function works for all kinds of futures but behavior depends on the input:<itemizedlist>
<listitem><para>If the previous future is continuable, attach the function to the continuation list</para>
</listitem><listitem><para>If the previous future is not continuable (such as std::future), post to execution with deferred policy. In both cases, the result becomes a cfuture or jcfuture.</para>
</listitem></itemizedlist>
</para>
<para>Stop tokens are also propagated:<itemizedlist>
<listitem><para>If after function expects a stop token:<itemizedlist>
<listitem><para>If previous future is stoppable and not-shared: return jcfuture with shared stop source</para>
</listitem><listitem><para>Otherwise: return jcfuture with new stop source</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para>If after function does not expect a stop token:<itemizedlist>
<listitem><para>If previous future is stoppable and not-shared: return jcfuture with shared stop source</para>
</listitem><listitem><para>Otherwise: return cfuture with no stop source</para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>before</parametername>
</parameternamelist>
<parameterdescription>
<para>The antecedent future </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>after</parametername>
</parameternamelist>
<parameterdescription>
<para>The continuation callable </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A continuation to the before future   </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ex</parametername>
</parameternamelist>
<parameterdescription>
<para>The executor </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/adaptor/then.hpp" line="154" column="9" bodyfile="futures/adaptor/then.hpp" bodystart="154" bodyend="159"/>
      </memberdef>
      <memberdef kind="function" id="group__adaptors_1ga8e228fec77e89e5071dbd391d2d01523" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>future_like</type>
            <declname>Future</declname>
            <defname>Future</defname>
          </param>
          <param>
            <type>class Function</type>
          </param>
        </templateparamlist>
        <type>__see_below__</type>
        <definition>__see_below__ futures::operator&gt;&gt;</definition>
        <argsstring>(Future &amp;&amp;before, Function &amp;&amp;after)</argsstring>
        <name>operator&gt;&gt;</name>
        <qualifiedname>futures::operator&gt;&gt;</qualifiedname>
        <param>
          <type>Future &amp;&amp;</type>
          <declname>before</declname>
        </param>
        <param>
          <type>Function &amp;&amp;</type>
          <declname>after</declname>
        </param>
    <requiresclause>( !is_executor_v&lt;std::decay_t&lt;Function&gt;&gt; &amp;&amp; !is_executor_v&lt;std::decay_t&lt;Future&gt;&gt; &amp;&amp; detail::next_future_traits&lt; default_executor_type, std::decay_t&lt;Function&gt;, std::decay_t&lt;Future&gt;&gt;::is_valid)    </requiresclause>
        <briefdescription>
<para>Operator to schedule a continuation function to a future. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>A continuation to the before future </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/adaptor/then.hpp" line="189" column="5" bodyfile="futures/adaptor/then.hpp" bodystart="189" bodyend="191"/>
      </memberdef>
      <memberdef kind="function" id="group__adaptors_1ga47832f9e4e10be3eec7abc2083d85be0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Executor</type>
          </param>
          <param>
            <type>class Future</type>
          </param>
          <param>
            <type>class Function</type>
          </param>
          <param>
            <type>bool</type>
            <declname>RValue</declname>
            <defname>RValue</defname>
          </param>
        </templateparamlist>
        <type>__see_below__</type>
        <definition>__see_below__ futures::operator&gt;&gt;</definition>
        <argsstring>(Future &amp;&amp;before, detail::executor_and_callable_reference&lt; Executor, Function, RValue &gt; &amp;&amp;after)</argsstring>
        <name>operator&gt;&gt;</name>
        <qualifiedname>futures::operator&gt;&gt;</qualifiedname>
        <param>
          <type>Future &amp;&amp;</type>
          <declname>before</declname>
        </param>
        <param>
          <type>detail::executor_and_callable_reference&lt; Executor, Function, RValue &gt; &amp;&amp;</type>
          <declname>after</declname>
        </param>
    <requiresclause>( is_executor_v&lt;std::decay_t&lt;Executor&gt;&gt; &amp;&amp; !is_executor_v&lt;std::decay_t&lt;Function&gt;&gt; &amp;&amp; !is_executor_v&lt;std::decay_t&lt;Future&gt;&gt; &amp;&amp; is_future_like_v&lt;std::decay_t&lt;Future&gt;&gt; &amp;&amp; detail::next_future_traits&lt; Executor, std::decay_t&lt;Function&gt;, std::decay_t&lt;Future&gt;&gt;::is_valid)    </requiresclause>
        <briefdescription>
<para>Schedule a continuation function to a future.   </para>
        </briefdescription>
        <detaileddescription>
<para>This function creates a continuation that gets executed when the <computeroutput>before</computeroutput> future is completed. The continuation needs to be invocable with the return type of the previous future.</para>
<para>This function works for all kinds of futures but behavior depends on the input:<itemizedlist>
<listitem><para>If the previous future is continuable, attach the function to the continuation list</para>
</listitem><listitem><para>If the previous future is not continuable (such as std::future), post to execution with deferred policy. In both cases, the result becomes a cfuture or jcfuture.</para>
</listitem></itemizedlist>
</para>
<para>Stop tokens are also propagated:<itemizedlist>
<listitem><para>If after function expects a stop token:<itemizedlist>
<listitem><para>If previous future is stoppable and not-shared: return jcfuture with shared stop source</para>
</listitem><listitem><para>Otherwise: return jcfuture with new stop source</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para>If after function does not expect a stop token:<itemizedlist>
<listitem><para>If previous future is stoppable and not-shared: return jcfuture with shared stop source</para>
</listitem><listitem><para>Otherwise: return cfuture with no stop source</para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>before</parametername>
</parameternamelist>
<parameterdescription>
<para>The antecedent future </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>after</parametername>
</parameternamelist>
<parameterdescription>
<para>The continuation callable </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A continuation to the before future   </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/adaptor/then.hpp" line="224" column="5" bodyfile="futures/adaptor/then.hpp" bodystart="224" bodyend="232"/>
      </memberdef>
      <memberdef kind="function" id="group__adaptors_1gaf29fa7770136bef87fc206de9ced9485" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class InputIt</type>
          </param>
        </templateparamlist>
        <type><ref refid="classfutures_1_1when__all__future" kindref="compound">when_all_future</ref>&lt; __see_below__ &gt;</type>
        <definition>when_all_future&lt; __see_below__ &gt; futures::when_all</definition>
        <argsstring>(InputIt first, InputIt last)</argsstring>
        <name>when_all</name>
        <qualifiedname>futures::when_all</qualifiedname>
        <param>
          <type>InputIt</type>
          <declname>first</declname>
        </param>
        <param>
          <type>InputIt</type>
          <declname>last</declname>
        </param>
    <requiresclause>detail::disjunction_v&lt; is_future_like&lt;std::decay_t&lt;std::iter_value_t&lt;InputIt&gt;&gt;&gt;, detail::is_invocable&lt;std::decay_t&lt;std::iter_value_t&lt;InputIt&gt;&gt;&gt;&gt;    </requiresclause>
        <briefdescription>
<para>Create a future object that becomes ready when the range of input futures becomes ready. </para>
        </briefdescription>
        <detaileddescription>
<para>This function does not participate in overload resolution unless InputIt&apos;s value type (i.e., typename std::iter_value_t&lt;InputIt&gt;) is a std::future or std::shared_future.</para>
<para>This overload uses a small vector for avoid further allocations for such a simple operation.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Range of futures </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Future object of type <ref refid="classfutures_1_1when__all__future" kindref="compound">when_all_future</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/adaptor/when_all.hpp" line="406" column="5" declfile="futures/adaptor/when_all.hpp" declline="406" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__adaptors_1ga5631320ae4a5b964c93f9ba3a812c3a1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Range</type>
          </param>
        </templateparamlist>
        <type><ref refid="classfutures_1_1when__all__future" kindref="compound">when_all_future</ref>&lt; __see_below__ &gt;</type>
        <definition>when_all_future&lt; __see_below__ &gt; futures::when_all</definition>
        <argsstring>(Range &amp;&amp;r)</argsstring>
        <name>when_all</name>
        <qualifiedname>futures::when_all</qualifiedname>
        <param>
          <type>Range &amp;&amp;</type>
          <declname>r</declname>
        </param>
    <requiresclause>is_range_v&lt;std::decay_t&lt;Range&gt;&gt;    </requiresclause>
        <briefdescription>
<para>Create a future object that becomes ready when the range of input futures becomes ready.   </para>
        </briefdescription>
        <detaileddescription>
<para>This function does not participate in overload resolution unless the range <ref refid="structfutures_1_1is__future__like" kindref="compound">is_future_like</ref> trait.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>r</parametername>
</parameternamelist>
<parameterdescription>
<para>Range of futures </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Future object of type <ref refid="classfutures_1_1when__all__future" kindref="compound">when_all_future</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/adaptor/when_all.hpp" line="427" column="5" bodyfile="futures/adaptor/when_all.hpp" bodystart="427" bodyend="433"/>
      </memberdef>
      <memberdef kind="function" id="group__adaptors_1ga8203d4f82bf8ee3bffae100123b0c601" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class...</type>
            <declname>Futures</declname>
            <defname>Futures</defname>
          </param>
        </templateparamlist>
        <type><ref refid="classfutures_1_1when__all__future" kindref="compound">when_all_future</ref>&lt; std::tuple&lt; __see_below__ &gt; &gt;</type>
        <definition>when_all_future&lt; std::tuple&lt; __see_below__ &gt; &gt; futures::when_all</definition>
        <argsstring>(Futures &amp;&amp;...futures)</argsstring>
        <name>when_all</name>
        <qualifiedname>futures::when_all</qualifiedname>
        <param>
          <type>Futures &amp;&amp;...</type>
          <declname>futures</declname>
        </param>
    <requiresclause>detail::conjunction_v&lt;detail::disjunction&lt; is_future_like&lt;std::decay_t&lt;Futures&gt;&gt;, detail::is_invocable&lt;std::decay_t&lt;Futures&gt;&gt;&gt;...&gt;    </requiresclause>
        <briefdescription>
<para>Create a future object that becomes ready when the range of input futures becomes ready.   </para>
        </briefdescription>
        <detaileddescription>
<para>This function does not participate in overload resolution unless every argument is either a (possibly cv-qualified) shared_future or a cv-unqualified future, as defined by the <ref refid="structfutures_1_1is__future__like" kindref="compound">is_future_like</ref> trait.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>futures</parametername>
</parameternamelist>
<parameterdescription>
<para>Instances of future objects </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Future object of type <ref refid="classfutures_1_1when__all__future" kindref="compound">when_all_future</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/adaptor/when_all.hpp" line="461" column="5" declfile="futures/adaptor/when_all.hpp" declline="461" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__adaptors_1ga2339ff3a16ab28b15882e8051977f2cb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T1</type>
          </param>
          <param>
            <type>class T2</type>
          </param>
        </templateparamlist>
        <type>__see_below__</type>
        <definition>__see_below__ futures::operator&amp;&amp;</definition>
        <argsstring>(T1 &amp;&amp;lhs, T2 &amp;&amp;rhs)</argsstring>
        <name>operator&amp;&amp;</name>
        <qualifiedname>futures::operator&amp;&amp;</qualifiedname>
        <param>
          <type>T1 &amp;&amp;</type>
          <declname>lhs</declname>
        </param>
        <param>
          <type>T2 &amp;&amp;</type>
          <declname>rhs</declname>
        </param>
    <requiresclause>detail::disjunction_v&lt; is_future_like&lt;std::decay_t&lt;T1&gt;&gt;, detail::is_invocable&lt;std::decay_t&lt;T1&gt;&gt;&gt; &amp;&amp; detail::disjunction_v&lt; is_future_like&lt;std::decay_t&lt;T2&gt;&gt;, detail::is_invocable&lt;std::decay_t&lt;T2&gt;&gt;&gt;    </requiresclause>
        <briefdescription>
<para>Create a future object that becomes ready when the range of input futures becomes ready.   </para>
        </briefdescription>
        <detaileddescription>
<para>Operator&amp;&amp; works for futures and functions (which are converted to futures with the default executor) If the future is a when_all_future itself, then it gets merged instead of becoming a child future of another when_all_future.</para>
<para>When the user asks for <computeroutput>f1 &amp;&amp; f2 &amp;&amp; f3</computeroutput>, we want that to return a single future that waits for <computeroutput>&lt;f1,f2,f3&gt;</computeroutput> rather than a future that wait for two futures <computeroutput>&lt;f1,&lt;f2,f3&gt;&gt;</computeroutput>.</para>
<para>This emulates the usual behavior we expect from other types with operator&amp;&amp;.</para>
<para>Note that this default behaviour is different from <computeroutput>when_all(...)</computeroutput>, which doesn&apos;t merge the when_all_future objects by default, because they are variadic functions and this intention can be controlled explicitly:<itemizedlist>
<listitem><para><computeroutput>when_all(f1,f2,f3)</computeroutput> -&gt; <computeroutput>&lt;f1,f2,f3&gt;</computeroutput></para>
</listitem><listitem><para><computeroutput>when_all(f1,when_all(f2,f3))</computeroutput> -&gt; <computeroutput>&lt;f1,&lt;f2,f3&gt;&gt;</computeroutput></para>
</listitem></itemizedlist>
</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>lhs</parametername>
<parametername>rhs</parametername>
</parameternamelist>
<parameterdescription>
<para>Future objects or callables </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classfutures_1_1when__all__future" kindref="compound">when_all_future</ref> object that concatenates all futures </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/adaptor/when_all.hpp" line="509" column="5" declfile="futures/adaptor/when_all.hpp" declline="509" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__adaptors_1ga326cd907b4a3bf8a50327d66ce41bead" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class InputIt</type>
          </param>
        </templateparamlist>
        <type><ref refid="classfutures_1_1when__any__future" kindref="compound">when_any_future</ref>&lt; __see_below__ &gt;</type>
        <definition>when_any_future&lt; __see_below__ &gt; futures::when_any</definition>
        <argsstring>(InputIt first, InputIt last)</argsstring>
        <name>when_any</name>
        <qualifiedname>futures::when_any</qualifiedname>
        <param>
          <type>InputIt</type>
          <declname>first</declname>
        </param>
        <param>
          <type>InputIt</type>
          <declname>last</declname>
        </param>
    <requiresclause>( is_future_like_v&lt;std::decay_t&lt;std::iter_value_t&lt;InputIt&gt;&gt;&gt; || detail::is_invocable_v&lt;std::iter_value_t&lt;InputIt&gt;&gt;)    </requiresclause>
        <briefdescription>
<para>Create a future object that becomes ready when any of the futures in the range is ready. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Range of futures </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classfutures_1_1when__any__future" kindref="compound">when_any_future</ref> with all future objects. The sequence type is a range object holding the futures. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/adaptor/when_any.hpp" line="509" column="2" declfile="futures/adaptor/when_any.hpp" declline="509" declcolumn="2"/>
      </memberdef>
      <memberdef kind="function" id="group__adaptors_1ga842a1ff92d9194317719529dcd49b42d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>std::ranges::range</type>
            <declname>Range</declname>
            <defname>Range</defname>
          </param>
        </templateparamlist>
        <type><ref refid="classfutures_1_1when__any__future" kindref="compound">when_any_future</ref>&lt; __see_below__ &gt;</type>
        <definition>when_any_future&lt; __see_below__ &gt; futures::when_any</definition>
        <argsstring>(Range &amp;&amp;r)</argsstring>
        <name>when_any</name>
        <qualifiedname>futures::when_any</qualifiedname>
        <param>
          <type>Range &amp;&amp;</type>
          <declname>r</declname>
        </param>
        <briefdescription>
<para>Create a future object that becomes ready when any of the futures in the range is ready.   </para>
        </briefdescription>
        <detaileddescription>
<para>This function does not participate in overload resolution unless every argument is future-like.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>r</parametername>
</parameternamelist>
<parameterdescription>
<para>Range of futures </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classfutures_1_1when__any__future" kindref="compound">when_any_future</ref> with all future objects </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/adaptor/when_any.hpp" line="530" column="5" bodyfile="futures/adaptor/when_any.hpp" bodystart="530" bodyend="534"/>
      </memberdef>
      <memberdef kind="function" id="group__adaptors_1gaeba0729046288863d01773d2e13c5f13" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class...</type>
            <declname>Futures</declname>
            <defname>Futures</defname>
          </param>
        </templateparamlist>
        <type><ref refid="classfutures_1_1when__any__future" kindref="compound">when_any_future</ref>&lt; std::tuple&lt; __see_below__ &gt; &gt;</type>
        <definition>when_any_future&lt; std::tuple&lt; __see_below__ &gt; &gt; futures::when_any</definition>
        <argsstring>(Futures &amp;&amp;...futures)</argsstring>
        <name>when_any</name>
        <qualifiedname>futures::when_any</qualifiedname>
        <param>
          <type>Futures &amp;&amp;...</type>
          <declname>futures</declname>
        </param>
    <requiresclause>detail::conjunction_v&lt;detail::disjunction&lt; is_future_like&lt;std::decay_t&lt;Futures&gt;&gt;, detail::is_invocable&lt;std::decay_t&lt;Futures&gt;&gt;&gt;...&gt;    </requiresclause>
        <briefdescription>
<para>Create a future object that becomes ready when any of the futures in the range is ready.   </para>
        </briefdescription>
        <detaileddescription>
<para>This function does not participate in overload resolution unless every argument is either a (possibly cv-qualified) std::shared_future or a cv-unqualified std::future.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>futures</parametername>
</parameternamelist>
<parameterdescription>
<para>A sequence of future objects </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classfutures_1_1when__any__future" kindref="compound">when_any_future</ref> with all future objects </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/adaptor/when_any.hpp" line="563" column="5" declfile="futures/adaptor/when_any.hpp" declline="563" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__adaptors_1ga2d3466eb250f13d9c7f909c4a07a787f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T1</type>
          </param>
          <param>
            <type>class T2</type>
          </param>
        </templateparamlist>
        <type>__see_below__</type>
        <definition>__see_below__ futures::operator||</definition>
        <argsstring>(T1 &amp;&amp;lhs, T2 &amp;&amp;rhs)</argsstring>
        <name>operator||</name>
        <qualifiedname>futures::operator||</qualifiedname>
        <param>
          <type>T1 &amp;&amp;</type>
          <declname>lhs</declname>
        </param>
        <param>
          <type>T2 &amp;&amp;</type>
          <declname>rhs</declname>
        </param>
    <requiresclause>detail::disjunction_v&lt; is_future_like&lt;std::decay_t&lt;T1&gt;&gt;, detail::is_invocable&lt;std::decay_t&lt;T1&gt;&gt;&gt; &amp;&amp; detail::disjunction_v&lt; is_future_like&lt;std::decay_t&lt;T2&gt;&gt;, detail::is_invocable&lt;std::decay_t&lt;T2&gt;&gt;&gt;    </requiresclause>
        <briefdescription>
<para>Create a future object that becomes ready when any of the futures in the range is ready.   </para>
        </briefdescription>
        <detaileddescription>
<para>ready operator|| works for futures and functions (which are converted to futures with the default executor) If the future is a when_any_future itself, then it gets merged instead of becoming a child future of another when_any_future.</para>
<para>When the user asks for <computeroutput>f1 || f2 || f3</computeroutput>, we want that to return a single future that waits for <computeroutput>&lt;f1 || f2 || f3&gt;</computeroutput> rather than a future that wait for two futures <computeroutput>&lt;f1 || &lt;f2 || f3&gt;&gt;</computeroutput>.</para>
<para>This emulates the usual behavior we expect from other types with <computeroutput>operator||</computeroutput>.</para>
<para>Note that this default behaviour is different from `when_any(...), which doesn&apos;t merge the when_any_future objects by default, because they are variadic functions and this intention can be controlled explicitly:<itemizedlist>
<listitem><para><computeroutput>when_any(f1,f2,f3)</computeroutput> -&gt; <computeroutput>&lt;f1 || f2 || f3&gt;</computeroutput></para>
</listitem><listitem><para><computeroutput>when_any(f1,when_any(f2,f3))</computeroutput> -&gt; <computeroutput>&lt;f1 || &lt;f2 || f3&gt;&gt;</computeroutput></para>
</listitem></itemizedlist>
</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>lhs</parametername>
<parametername>rhs</parametername>
</parameternamelist>
<parameterdescription>
<para>Future objects </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A <ref refid="classfutures_1_1when__any__future" kindref="compound">when_any_future</ref> holding all future types </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/adaptor/when_any.hpp" line="611" column="5" declfile="futures/adaptor/when_any.hpp" declline="611" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__partitioners_1ga20c9290c9184f57260f5d6f8692d73b6" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr std::size_t</type>
        <definition>constexpr std::size_t futures::make_grain_size</definition>
        <argsstring>(std::size_t n)</argsstring>
        <name>make_grain_size</name>
        <qualifiedname>futures::make_grain_size</qualifiedname>
        <param>
          <type>std::size_t</type>
          <declname>n</declname>
        </param>
        <briefdescription>
<para>Determine a reasonable minimum grain size depending on the number of elements in a sequence. </para>
        </briefdescription>
        <detaileddescription>
<para>The grain size considers the number of threads available. It&apos;s never more than 2048 elements.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>Sequence size </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The recommended grain size for a range of the specified size </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/partitioner/default_partitioner.hpp" line="47" column="5" bodyfile="futures/algorithm/partitioner/default_partitioner.hpp" bodystart="47" bodyend="58"/>
      </memberdef>
      <memberdef kind="function" id="group__partitioners_1ga47766e8c4150a6b098bf298023669558" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="group__partitioners_1ga1dfbb885c6bb2f86870d55160dd16783" kindref="member">default_partitioner</ref></type>
        <definition>default_partitioner futures::make_default_partitioner</definition>
        <argsstring>(size_t n)</argsstring>
        <name>make_default_partitioner</name>
        <qualifiedname>futures::make_default_partitioner</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>n</declname>
        </param>
        <briefdescription>
<para>Create an instance of the default partitioner with a reasonable grain size for <computeroutput>n</computeroutput> elements. </para>
        </briefdescription>
        <detaileddescription>
<para>The default partitioner type and parameters might change </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/partitioner/default_partitioner.hpp" line="66" column="5" bodyfile="futures/algorithm/partitioner/default_partitioner.hpp" bodystart="66" bodyend="68"/>
      </memberdef>
      <memberdef kind="function" id="group__partitioners_1ga39395da895517ad34cfa27ef8b1d6d87" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>std::input_iterator</type>
            <declname>I</declname>
            <defname>I</defname>
          </param>
          <param>
            <type>std::sentinel_for&lt; I &gt;</type>
            <declname>S</declname>
            <defname>S</defname>
          </param>
        </templateparamlist>
        <type><ref refid="group__partitioners_1ga1dfbb885c6bb2f86870d55160dd16783" kindref="member">default_partitioner</ref></type>
        <definition>default_partitioner futures::make_default_partitioner</definition>
        <argsstring>(I first, S last)</argsstring>
        <name>make_default_partitioner</name>
        <qualifiedname>futures::make_default_partitioner</qualifiedname>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>S</type>
          <declname>last</declname>
        </param>
        <briefdescription>
<para>Create an instance of the default partitioner with a reasonable grain for the range <computeroutput>first</computeroutput>, <computeroutput>last</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para>The default partitioner type and parameters might change </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/partitioner/default_partitioner.hpp" line="85" column="5" bodyfile="futures/algorithm/partitioner/default_partitioner.hpp" bodystart="85" bodyend="87"/>
      </memberdef>
      <memberdef kind="function" id="group__partitioners_1ga27d6c718a4152cd510382df27662a199" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class R</type>
          </param>
        </templateparamlist>
        <type><ref refid="group__partitioners_1ga1dfbb885c6bb2f86870d55160dd16783" kindref="member">default_partitioner</ref></type>
        <definition>default_partitioner futures::make_default_partitioner</definition>
        <argsstring>(R &amp;&amp;r)</argsstring>
        <name>make_default_partitioner</name>
        <qualifiedname>futures::make_default_partitioner</qualifiedname>
        <param>
          <type>R &amp;&amp;</type>
          <declname>r</declname>
        </param>
    <requiresclause>is_input_range_v&lt;R&gt;    </requiresclause>
        <briefdescription>
<para>Create an instance of the default partitioner with a reasonable grain for the range <computeroutput>r</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para>The default partitioner type and parameters might change </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/algorithm/partitioner/default_partitioner.hpp" line="101" column="5" bodyfile="futures/algorithm/partitioner/default_partitioner.hpp" bodystart="101" bodyend="103"/>
      </memberdef>
      <memberdef kind="function" id="group__waiting_1ga3aff4d8b5cd3b961aaf86f0c59652d5e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>future_like</type>
            <declname>Future</declname>
            <defname>Future</defname>
          </param>
        </templateparamlist>
        <type>__see_below__</type>
        <definition>__see_below__ futures::await</definition>
        <argsstring>(Future &amp;&amp;f)</argsstring>
        <name>await</name>
        <qualifiedname>futures::await</qualifiedname>
        <param>
          <type>Future &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Wait for future types and retrieve their values. </para>
        </briefdescription>
        <detaileddescription>
<para>This syntax is most useful for cases where we are immediately requesting the future result.</para>
<para>The function also makes the syntax optionally a little closer to languages such as javascript.</para>
<para><simplesect kind="note"><para>This function only participates in overload resolution if all types are futures.</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>A future object</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The result of the future object </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/await.hpp" line="60" column="5" bodyfile="futures/await.hpp" bodystart="60" bodyend="62"/>
      </memberdef>
      <memberdef kind="function" id="group__waiting_1ga6e65f21a7e07afbab340ede45e568068" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>future_like...</type>
            <declname>Futures</declname>
            <defname>Futures</defname>
          </param>
        </templateparamlist>
        <type>__see_below__</type>
        <definition>__see_below__ futures::await</definition>
        <argsstring>(Futures &amp;&amp;...fs)</argsstring>
        <name>await</name>
        <qualifiedname>futures::await</qualifiedname>
        <param>
          <type>Futures &amp;&amp;...</type>
          <declname>fs</declname>
        </param>
        <briefdescription>
<para>Wait for future types and retrieve their values as a tuple. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>This function only participates in overload resolution if all types are futures.</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fs</parametername>
</parameternamelist>
<parameterdescription>
<para>Future objects</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The result of the future object </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/await.hpp" line="84" column="5" bodyfile="futures/await.hpp" bodystart="84" bodyend="88"/>
      </memberdef>
      <memberdef kind="function" id="group__executors_1ga046c80f7c9ec8c63cd18bebe62f3ce3f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__executors_1gaf961f88543ab12949fd90f310bc90663" kindref="member">default_execution_context_type</ref> &amp;</type>
        <definition>default_execution_context_type &amp; futures::default_execution_context</definition>
        <argsstring>()</argsstring>
        <name>default_execution_context</name>
        <qualifiedname>futures::default_execution_context</qualifiedname>
        <briefdescription>
<para>Create an instance of the default execution context. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>Reference to the default execution context for <ref refid="group__launch_1gafcb2799edc3dab5292f720d81f7be75e" kindref="member">async</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/executor/default_executor.hpp" line="64" column="5" declfile="futures/executor/default_executor.hpp" declline="64" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__executors_1ga1ab933a38b4db38d0955b3e6764dd90d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>default_execution_context_type::executor_type</type>
        <definition>default_execution_context_type::executor_type futures::make_default_executor</definition>
        <argsstring>()</argsstring>
        <name>make_default_executor</name>
        <qualifiedname>futures::make_default_executor</qualifiedname>
        <briefdescription>
<para>Create an Asio thread pool executor for the default thread pool. </para>
        </briefdescription>
        <detaileddescription>
<para>In the executors notation:<itemizedlist>
<listitem><para>Executor: set of rules governing where, when and how to run a function object<itemizedlist>
<listitem><para>A thread pool is an execution context for which we can create executors pointing to the pool.</para>
</listitem><listitem><para>The executor rule for the default thread pool executor is to run function objects in the pool and nowhere else.</para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para>
<para>An executor is:<itemizedlist>
<listitem><para>Lightweight and copyable (just references and pointers to the execution context).</para>
</listitem><listitem><para>May be long or short lived.</para>
</listitem><listitem><para>May be customized on a fine-grained basis, such as exception behavior, and order</para>
</listitem></itemizedlist>
</para>
<para>There might be many executor types associated with with the same execution context.</para>
<para><simplesect kind="return"><para>Executor handle to the default execution context </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/executor/default_executor.hpp" line="90" column="5" declfile="futures/executor/default_executor.hpp" declline="90" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespacefutures_1a7b2a38e1190a1de44f046e7aa3101980" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>executor_for&lt; F &gt;</type>
            <declname>E</declname>
            <defname>E</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void futures::execute</definition>
        <argsstring>(E const &amp;ex, F &amp;&amp;f)</argsstring>
        <name>execute</name>
        <qualifiedname>futures::execute</qualifiedname>
        <param>
          <type>E const &amp;</type>
          <declname>ex</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Submits a task for execution. </para>
        </briefdescription>
        <detaileddescription>
<para>This free function submits a task for execution using the specified executor.</para>
<para>Unlike the <computeroutput>execute</computeroutput> member function of executors, this function identifies and interoperates with other executor types, such as Asio executors. If an execution context is provided, its executor is retrived and used instead.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ex</parametername>
</parameternamelist>
<parameterdescription>
<para>The target executor </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The task </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/executor/execute.hpp" line="40" column="5" bodyfile="futures/executor/execute.hpp" bodystart="40" bodyend="42"/>
      </memberdef>
      <memberdef kind="function" id="namespacefutures_1afcf0c0be15dabc267db8b38925813a97" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>execution_context_for&lt; F &gt;</type>
            <declname>C</declname>
            <defname>C</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void futures::execute</definition>
        <argsstring>(C &amp;ctx, F &amp;&amp;f)</argsstring>
        <name>execute</name>
        <qualifiedname>futures::execute</qualifiedname>
        <param>
          <type>C &amp;</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
    <requiresclause>(!executor_for&lt;C, F&gt;)    </requiresclause>
        <briefdescription>
<para>Submits a task for execution on an execution context. </para>
        </briefdescription>
        <detaileddescription>
<para>This free function submits a task for execution using the specified execution context.</para>
<para>This is a convenience function that extracts the executor from the context and uses it instead.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>The target execution context </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The task </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/executor/execute.hpp" line="68" column="10" bodyfile="futures/executor/execute.hpp" bodystart="68" bodyend="70"/>
      </memberdef>
      <memberdef kind="function" id="group__executors_1gaa58c1bc10fe96080f355b709a30473f6" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>unsigned int</type>
        <definition>unsigned int futures::hardware_concurrency</definition>
        <argsstring>() noexcept</argsstring>
        <name>hardware_concurrency</name>
        <qualifiedname>futures::hardware_concurrency</qualifiedname>
        <briefdescription>
<para>A version of hardware_concurrency that always returns at least 1. </para>
        </briefdescription>
        <detaileddescription>
<para>This function is a safer version of hardware_concurrency that always returns at least 1 to represent the current context when the value is not computable.</para>
<para><itemizedlist>
<listitem><para>It never returns 0, 1 is returned instead.</para>
</listitem><listitem><para>It is guaranteed to remain constant for the duration of the program.</para>
</listitem></itemizedlist>
</para>
<para>It also improves on hardware_concurrency to provide a default value of 1 when the function is being executed at compile time. This allows partitioners and algorithms to be constexpr.</para>
<para><simplesect kind="see"><para><ulink url="https://en.cppreference.com/w/cpp/thread/thread/hardware_concurrency"><computeroutput>std::hardware_concurrency</computeroutput></ulink></para>
</simplesect>
<simplesect kind="return"><para>Number of concurrent threads supported. If the value is not well-defined or not computable, returns 1. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/executor/hardware_concurrency.hpp" line="47" column="5" bodyfile="futures/executor/hardware_concurrency.hpp" bodystart="47" bodyend="57"/>
      </memberdef>
      <memberdef kind="function" id="group__executors_1ga8402f32dc6d52a81897b54b45ec84616" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr <ref refid="classfutures_1_1inline__executor" kindref="compound">inline_executor</ref></type>
        <definition>constexpr inline_executor futures::make_inline_executor</definition>
        <argsstring>()</argsstring>
        <name>make_inline_executor</name>
        <qualifiedname>futures::make_inline_executor</qualifiedname>
        <briefdescription>
<para>Make an inline executor object. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/executor/inline_executor.hpp" line="48" column="5" bodyfile="futures/executor/inline_executor.hpp" bodystart="48" bodyend="50"/>
      </memberdef>
      <memberdef kind="function" id="group__executors_1ga421a5f50523a4c393344869afbb7a85f" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr <ref refid="classfutures_1_1new__thread__executor" kindref="compound">new_thread_executor</ref></type>
        <definition>constexpr new_thread_executor futures::make_new_thread_executor</definition>
        <argsstring>()</argsstring>
        <name>make_new_thread_executor</name>
        <qualifiedname>futures::make_new_thread_executor</qualifiedname>
        <briefdescription>
<para>Make an new thread executor object. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/executor/new_thread_executor.hpp" line="49" column="5" bodyfile="futures/executor/new_thread_executor.hpp" bodystart="49" bodyend="51"/>
      </memberdef>
      <memberdef kind="function" id="group__adaptors_1ga4b25abc5ba5c39102a1545d29d8c03a3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>future_like</type>
            <declname>Future</declname>
            <defname>Future</defname>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool futures::is_ready</definition>
        <argsstring>(Future &amp;&amp;f)</argsstring>
        <name>is_ready</name>
        <qualifiedname>futures::is_ready</qualifiedname>
        <param>
          <type>Future &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Check if a future is ready. </para>
        </briefdescription>
        <detaileddescription>
<para>Although basic_future has its more efficient is_ready function, this free function allows us to query other futures that don&apos;t implement is_ready, such as std::future. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/is_ready.hpp" line="45" column="5" declfile="futures/is_ready.hpp" declline="45" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__launch_1gafcb2799edc3dab5292f720d81f7be75e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>executor</type>
            <declname>Executor</declname>
            <defname>Executor</defname>
          </param>
          <param>
            <type>class Function</type>
          </param>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>__see_below__</type>
        <definition>__see_below__ futures::async</definition>
        <argsstring>(Executor const &amp;ex, Function &amp;&amp;f, Args &amp;&amp;...args)</argsstring>
        <name>async</name>
        <qualifiedname>futures::async</qualifiedname>
        <param>
          <type>Executor const &amp;</type>
          <declname>ex</declname>
        </param>
        <param>
          <type>Function &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Args &amp;&amp;...</type>
          <declname>args</declname>
        </param>
    <requiresclause>( detail::is_invocable_v&lt;Function, Args...&gt; || detail::is_invocable_v&lt;Function, stop_token, Args...&gt;)    </requiresclause>
        <briefdescription>
<para>Launch an asynchronous task with the specified executor. </para>
        </briefdescription>
        <detaileddescription>
<para>This version of the async function will always use the specified executor instead of creating a new thread.</para>
<para>If no executor is provided, then the function is run in a default executor created from the default thread pool. The default executor also ensures the function will not launch one thread per task.</para>
<para>The task might accept a stop token as its first parameter, in which case the function returns a continuable and stoppable future type. Otherwise, this function returns a continuable future type.</para>
<para><simplesect kind="par"><title>Example</title><para><programlisting><codeline><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>f<sp/>=<sp/><ref refid="group__launch_1gafcb2799edc3dab5292f720d81f7be75e" kindref="member">async</ref>(ex,<sp/>[]()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>2;<sp/>});</highlight></codeline>
<codeline><highlight class="normal">std::cout<sp/>&lt;&lt;<sp/>f.get()<sp/>&lt;&lt;<sp/>std::endl;<sp/></highlight><highlight class="comment">//<sp/>2</highlight></codeline>
</programlisting></para>
</simplesect>
<simplesect kind="see"><para><ref refid="classfutures_1_1basic__future" kindref="compound">basic_future</ref></para>
</simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Executor</parametername>
</parameternamelist>
<parameterdescription>
<para>Executor from an execution context </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Function</parametername>
</parameternamelist>
<parameterdescription>
<para>A callable object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Args</parametername>
</parameternamelist>
<parameterdescription>
<para>Arguments for the Function</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ex</parametername>
</parameternamelist>
<parameterdescription>
<para>Executor </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Function to execute </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>args</parametername>
</parameternamelist>
<parameterdescription>
<para>Function arguments</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An eager future object whose shared state refers to the task result. The type of this future object depends on the task. If the task expects a <ref refid="classfutures_1_1stop__token" kindref="compound">stop_token</ref>, the future will return a continuable, stoppable, eager future. Otherwise, the function will return a continuable eager future. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/launch.hpp" line="103" column="9" declfile="futures/launch.hpp" declline="103" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="group__launch_1ga85e60c1de0d37a14ec5623e85ae9a0c7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Function</type>
          </param>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>__see_below__</type>
        <definition>__see_below__ futures::async</definition>
        <argsstring>(Function &amp;&amp;f, Args &amp;&amp;...args)</argsstring>
        <name>async</name>
        <qualifiedname>futures::async</qualifiedname>
        <param>
          <type>Function &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Args &amp;&amp;...</type>
          <declname>args</declname>
        </param>
    <requiresclause>( !is_executor_v&lt;Function&gt; &amp;&amp; (detail::is_invocable_v&lt;Function, Args...&gt; || detail::is_invocable_v&lt;Function, stop_token, Args...&gt;) )    </requiresclause>
        <briefdescription>
<para>Launch an asynchronous task with the default executor. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Executor</parametername>
</parameternamelist>
<parameterdescription>
<para>Executor from an execution context </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Function</parametername>
</parameternamelist>
<parameterdescription>
<para>A callable object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Args</parametername>
</parameternamelist>
<parameterdescription>
<para>Arguments for the Function</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Function to execute </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>args</parametername>
</parameternamelist>
<parameterdescription>
<para>Function arguments</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A future object with the function results </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/launch.hpp" line="128" column="19" declfile="futures/launch.hpp" declline="128" declcolumn="19"/>
      </memberdef>
      <memberdef kind="function" id="group__launch_1gaa3cac9f64c928b7c63acd65c6e17cc69" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>executor</type>
            <declname>Executor</declname>
            <defname>Executor</defname>
          </param>
          <param>
            <type>class Function</type>
          </param>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>__see_below__</type>
        <definition>__see_below__ futures::schedule</definition>
        <argsstring>(Executor const &amp;ex, Function &amp;&amp;f, Args &amp;&amp;...args)</argsstring>
        <name>schedule</name>
        <qualifiedname>futures::schedule</qualifiedname>
        <param>
          <type>Executor const &amp;</type>
          <declname>ex</declname>
        </param>
        <param>
          <type>Function &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Args &amp;&amp;...</type>
          <declname>args</declname>
        </param>
    <requiresclause>( (detail::is_invocable_v&lt;Function, Args...&gt; || detail::is_invocable_v&lt;Function, stop_token, Args...&gt;) )    </requiresclause>
        <briefdescription>
<para>Schedule an asynchronous task with the specified executor. </para>
        </briefdescription>
        <detaileddescription>
<para>This function schedules a deferred future. The task will only be launched in the executor when some other execution context waits for the value associated to this future.</para>
<para><simplesect kind="see"><para><ref refid="classfutures_1_1basic__future" kindref="compound">basic_future</ref></para>
</simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Executor</parametername>
</parameternamelist>
<parameterdescription>
<para>Executor from an execution context </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Function</parametername>
</parameternamelist>
<parameterdescription>
<para>A callable object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Args</parametername>
</parameternamelist>
<parameterdescription>
<para>Arguments for the Function</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ex</parametername>
</parameternamelist>
<parameterdescription>
<para>Executor </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Function to execute </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>args</parametername>
</parameternamelist>
<parameterdescription>
<para>Function arguments</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A deferred future object whose shared state refers to the task result. The type of this future object depends on the task. If the task expects a <ref refid="classfutures_1_1stop__token" kindref="compound">stop_token</ref>, the future will return a stoppable deferred future. Otherwise, the function will return a deferred future. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/launch.hpp" line="170" column="9" declfile="futures/launch.hpp" declline="170" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="group__launch_1ga5132dec81e533dfd824848751a1a3565" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Function</type>
          </param>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>__see_below__</type>
        <definition>__see_below__ futures::schedule</definition>
        <argsstring>(Function &amp;&amp;f, Args &amp;&amp;...args)</argsstring>
        <name>schedule</name>
        <qualifiedname>futures::schedule</qualifiedname>
        <param>
          <type>Function &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Args &amp;&amp;...</type>
          <declname>args</declname>
        </param>
    <requiresclause>( (!is_executor_v&lt;Function&gt; &amp;&amp; (detail::is_invocable_v&lt;Function, Args...&gt; || detail::is_invocable_v&lt;Function, stop_token, Args...&gt;) ))    </requiresclause>
        <briefdescription>
<para>Schedule an asynchronous task with the default executor. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Executor</parametername>
</parameternamelist>
<parameterdescription>
<para>Executor from an execution context </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Function</parametername>
</parameternamelist>
<parameterdescription>
<para>A callable object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Args</parametername>
</parameternamelist>
<parameterdescription>
<para>Arguments for the Function</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Function to execute </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>args</parametername>
</parameternamelist>
<parameterdescription>
<para>Function arguments</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A future object with the function results </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/launch.hpp" line="196" column="19" declfile="futures/launch.hpp" declline="196" declcolumn="19"/>
      </memberdef>
      <memberdef kind="function" id="group__shared__state_1ga320f807f067a8d02c4d0e9ed66e53b0b" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Signature</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void futures::swap</definition>
        <argsstring>(packaged_task&lt; Signature &gt; &amp;l, packaged_task&lt; Signature &gt; &amp;r) noexcept</argsstring>
        <name>swap</name>
        <qualifiedname>futures::swap</qualifiedname>
        <param>
          <type>packaged_task&lt; Signature &gt; &amp;</type>
          <declname>l</declname>
        </param>
        <param>
          <type>packaged_task&lt; Signature &gt; &amp;</type>
          <declname>r</declname>
        </param>
        <briefdescription>
<para>Specializes the std::swap algorithm. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/packaged_task.hpp" line="278" column="5" bodyfile="futures/packaged_task.hpp" bodystart="278" bodyend="280"/>
      </memberdef>
      <memberdef kind="function" id="group__shared__state_1ga9a3170dfeff3872b6a6bcfab5ce63e66" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename R</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void futures::swap</definition>
        <argsstring>(promise&lt; R &gt; &amp;l, promise&lt; R &gt; &amp;r) noexcept</argsstring>
        <name>swap</name>
        <qualifiedname>futures::swap</qualifiedname>
        <param>
          <type><ref refid="classfutures_1_1promise" kindref="compound">promise</ref>&lt; R &gt; &amp;</type>
          <declname>l</declname>
        </param>
        <param>
          <type><ref refid="classfutures_1_1promise" kindref="compound">promise</ref>&lt; R &gt; &amp;</type>
          <declname>r</declname>
        </param>
        <briefdescription>
<para>Swap the value of two promises. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/promise.hpp" line="251" column="5" bodyfile="futures/promise.hpp" bodystart="251" bodyend="253"/>
      </memberdef>
      <memberdef kind="function" id="group__error_1ga1d60ca812337944e729a84a9f37195ab" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void futures::handle_exception</definition>
        <argsstring>(std::exception const &amp;, boost::source_location const &amp;)</argsstring>
        <name>handle_exception</name>
        <qualifiedname>futures::handle_exception</qualifiedname>
        <param>
          <type>std::exception const &amp;</type>
        </param>
        <param>
          <type>boost::source_location const &amp;</type>
        </param>
        <briefdescription>
<para>Customization point to handle exceptions. </para>
        </briefdescription>
        <detaileddescription>
<para>When exception support is disabled with <ref refid="config_8hpp_1a88c5f8bac9b8cee5d61caf298c83cf49" kindref="member">FUTURES_NO_EXCEPTIONS</ref>, this function will be called to handle exceptions.</para>
<para>To customize how exceptions will be handled, define the macro <ref refid="config_8hpp_1aafd86f87f4188bfabe42994ad5b2fec4" kindref="member">FUTURES_CUSTOM_EXCEPTION_HANDLE</ref>, and define an alternative implementation for this function. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/throw.hpp" line="61" column="5" declfile="futures/throw.hpp" declline="61" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__error_1ga3ee1de4e2e5e2809f8936319b4b2ce09" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class E</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void futures::throw_exception</definition>
        <argsstring>(E &amp;&amp;e, source_location const &amp;loc=std::source_location::current())</argsstring>
        <name>throw_exception</name>
        <qualifiedname>futures::throw_exception</qualifiedname>
        <param>
          <type>E &amp;&amp;</type>
          <declname>e</declname>
        </param>
        <param>
          <type><ref refid="group__error_1gaa09c7b0f3e466783023afb96eea90fad" kindref="member">source_location</ref> const &amp;</type>
          <declname>loc</declname>
          <defval>std::source_location::current()</defval>
        </param>
        <briefdescription>
<para>Library function used to throw exceptions. </para>
        </briefdescription>
        <detaileddescription>
<para>This is the main library function used to throw exceptions according to the functions available for handling exceptions.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>Exception type </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>e</parametername>
</parameternamelist>
<parameterdescription>
<para>Exception object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>loc</parametername>
</parameternamelist>
<parameterdescription>
<para>Location where the exception occurred </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/throw.hpp" line="74" column="5" declfile="futures/throw.hpp" declline="74" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__waiting_1ga059ba1404ba968cb2cb108a76f9cffa8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>std::input_iterator</type>
            <declname>Iterator</declname>
            <defname>Iterator</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void futures::wait_for_all</definition>
        <argsstring>(Iterator first, Iterator last)</argsstring>
        <name>wait_for_all</name>
        <qualifiedname>futures::wait_for_all</qualifiedname>
        <param>
          <type>Iterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>Iterator</type>
          <declname>last</declname>
        </param>
    <requiresclause>future_like&lt;std::iter_value_t&lt;Iterator&gt;&gt;    </requiresclause>
        <briefdescription>
<para>Wait for a sequence of futures to be ready. </para>
        </briefdescription>
        <detaileddescription>
<para>This function waits for all futures in the range [<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) to be ready. It simply waits iteratively for each of the futures to be ready.</para>
<para><simplesect kind="note"><para>This function is adapted from boost::wait_for_all</para>
</simplesect>
<simplesect kind="see"><para><ulink url="https://www.boost.org/doc/libs/1_78_0/doc/html/thread/synchronization.html#thread.synchronization.futures.reference.wait_for_all">boost.thread wait_for_all</ulink></para>
</simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Iterator</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator type in a range of futures </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator to the first element in the range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator to one past the last element in the range </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/wait_for_all.hpp" line="60" column="5" bodyfile="futures/wait_for_all.hpp" bodystart="60" bodyend="64"/>
      </memberdef>
      <memberdef kind="function" id="group__waiting_1gabbd368b77796881cce9c951099f7a25a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>std::ranges::range</type>
            <declname>Range</declname>
            <defname>Range</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void futures::wait_for_all</definition>
        <argsstring>(Range &amp;&amp;r)</argsstring>
        <name>wait_for_all</name>
        <qualifiedname>futures::wait_for_all</qualifiedname>
        <param>
          <type>Range &amp;&amp;</type>
          <declname>r</declname>
        </param>
    <requiresclause>future_like&lt;std::ranges::range_value_t&lt;Range&gt;&gt;    </requiresclause>
        <briefdescription>
<para>Wait for a sequence of futures to be ready. </para>
        </briefdescription>
        <detaileddescription>
<para>This function waits for all futures in the range <computeroutput>r</computeroutput> to be ready. It simply waits iteratively for each of the futures to be ready.</para>
<para><simplesect kind="note"><para>This function is adapted from boost::wait_for_all</para>
</simplesect>
<simplesect kind="see"><para><ulink url="https://www.boost.org/doc/libs/1_78_0/doc/html/thread/synchronization.html#thread.synchronization.futures.reference.wait_for_all">boost.thread wait_for_all</ulink></para>
</simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Range</parametername>
</parameternamelist>
<parameterdescription>
<para>A range of futures type </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>r</parametername>
</parameternamelist>
<parameterdescription>
<para>Range of futures </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/wait_for_all.hpp" line="92" column="5" bodyfile="futures/wait_for_all.hpp" bodystart="92" bodyend="95"/>
      </memberdef>
      <memberdef kind="function" id="group__waiting_1gaa3ea0a0826fda6a1c9c7f9b5ad3be390" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>future_like...</type>
            <declname>Fs</declname>
            <defname>Fs</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void futures::wait_for_all</definition>
        <argsstring>(Fs &amp;&amp;...fs)</argsstring>
        <name>wait_for_all</name>
        <qualifiedname>futures::wait_for_all</qualifiedname>
        <param>
          <type>Fs &amp;&amp;...</type>
          <declname>fs</declname>
        </param>
        <briefdescription>
<para>Wait for a sequence of futures to be ready. </para>
        </briefdescription>
        <detaileddescription>
<para>This function waits for all specified futures <computeroutput>fs</computeroutput>... to be ready.</para>
<para>It creates a compile-time fixed-size data structure to store references to all of the futures and then waits for each of the futures to be ready.</para>
<para><simplesect kind="note"><para>This function is adapted from boost::wait_for_all</para>
</simplesect>
<simplesect kind="see"><para><ulink url="https://www.boost.org/doc/libs/1_78_0/doc/html/thread/synchronization.html#thread.synchronization.futures.reference.wait_for_all">boost.thread wait_for_all</ulink></para>
</simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Fs</parametername>
</parameternamelist>
<parameterdescription>
<para>A list of future types </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fs</parametername>
</parameternamelist>
<parameterdescription>
<para>A list of future objects </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/wait_for_all.hpp" line="125" column="5" bodyfile="futures/wait_for_all.hpp" bodystart="125" bodyend="133"/>
      </memberdef>
      <memberdef kind="function" id="group__waiting_1gadc987f5c0fbf9c029b6e4fd303778e06" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Tuple</type>
          </param>
        </templateparamlist>
        <type>::value void</type>
        <definition>::value void futures::wait_for_all</definition>
        <argsstring>(Tuple &amp;&amp;t)</argsstring>
        <name>wait_for_all</name>
        <qualifiedname>futures::wait_for_all</qualifiedname>
        <param>
          <type>Tuple &amp;&amp;</type>
          <declname>t</declname>
        </param>
    <requiresclause>detail::mp_similar&lt;std::tuple&lt;&gt;, std::decay_t&lt;Tuple&gt;&gt;    </requiresclause>
        <briefdescription>
<para>Wait for a sequence of futures to be ready. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/wait_for_all.hpp" line="148" column="5" bodyfile="futures/wait_for_all.hpp" bodystart="148" bodyend="150"/>
      </memberdef>
      <memberdef kind="function" id="group__waiting_1gabe48c8000499e7d6b858c2ba03f24f9d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Iterator</type>
          </param>
          <param>
            <type>class Rep</type>
          </param>
          <param>
            <type>class Period</type>
          </param>
        </templateparamlist>
        <type><ref refid="group__future-types_1ga2d9145fe40c699d6f0060bcddbf910a6" kindref="member">future_status</ref></type>
        <definition>future_status futures::wait_for_all_for</definition>
        <argsstring>(std::chrono::duration&lt; Rep, Period &gt; const &amp;timeout_duration, Iterator first, Iterator last)</argsstring>
        <name>wait_for_all_for</name>
        <qualifiedname>futures::wait_for_all_for</qualifiedname>
        <param>
          <type>std::chrono::duration&lt; Rep, Period &gt; const &amp;</type>
          <declname>timeout_duration</declname>
        </param>
        <param>
          <type>Iterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>Iterator</type>
          <declname>last</declname>
        </param>
    <requiresclause>is_future_like_v&lt;iter_value_t&lt;Iterator&gt;&gt;    </requiresclause>
        <briefdescription>
<para>Wait for a sequence of futures to be ready. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Iterator</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator type in a range of futures </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rep</parametername>
</parameternamelist>
<parameterdescription>
<para>Duration Rep </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Period</parametername>
</parameternamelist>
<parameterdescription>
<para>Duration Period </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>timeout_duration</parametername>
</parameternamelist>
<parameterdescription>
<para>Time to wait for </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator to the first element in the range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator to one past the last element in the range</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>future_status::ready</computeroutput> if all futures got ready. <computeroutput>future_status::timeout</computeroutput> otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/wait_for_all.hpp" line="175" column="5" declfile="futures/wait_for_all.hpp" declline="175" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__waiting_1ga03aaee3fbed390c33ca18829365f457f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Range</type>
          </param>
          <param>
            <type>class Rep</type>
          </param>
          <param>
            <type>class Period</type>
          </param>
        </templateparamlist>
        <type><ref refid="group__future-types_1ga2d9145fe40c699d6f0060bcddbf910a6" kindref="member">future_status</ref></type>
        <definition>future_status futures::wait_for_all_for</definition>
        <argsstring>(std::chrono::duration&lt; Rep, Period &gt; const &amp;timeout_duration, Range &amp;&amp;r)</argsstring>
        <name>wait_for_all_for</name>
        <qualifiedname>futures::wait_for_all_for</qualifiedname>
        <param>
          <type>std::chrono::duration&lt; Rep, Period &gt; const &amp;</type>
          <declname>timeout_duration</declname>
        </param>
        <param>
          <type>Range &amp;&amp;</type>
          <declname>r</declname>
        </param>
    <requiresclause>is_range_v&lt;Range&gt; &amp;&amp; is_future_like_v&lt;range_value_t&lt;Range&gt;&gt;    </requiresclause>
        <briefdescription>
<para>Wait for a sequence of futures to be ready. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Range</parametername>
</parameternamelist>
<parameterdescription>
<para>Range of futures </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rep</parametername>
</parameternamelist>
<parameterdescription>
<para>Duration Rep </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Period</parametername>
</parameternamelist>
<parameterdescription>
<para>Duration Period </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>timeout_duration</parametername>
</parameternamelist>
<parameterdescription>
<para>Time to wait for </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>r</parametername>
</parameternamelist>
<parameterdescription>
<para>Range of futures</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>future_status::ready</computeroutput> if all futures got ready. <computeroutput>future_status::timeout</computeroutput> otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/wait_for_all.hpp" line="205" column="5" bodyfile="futures/wait_for_all.hpp" bodystart="205" bodyend="210"/>
      </memberdef>
      <memberdef kind="function" id="group__waiting_1ga5ca790c41550c9952a733a5c3ec4f9d3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>future_like...</type>
            <declname>Fs</declname>
            <defname>Fs</defname>
          </param>
          <param>
            <type>class Rep</type>
          </param>
          <param>
            <type>class Period</type>
          </param>
        </templateparamlist>
        <type><ref refid="group__future-types_1ga2d9145fe40c699d6f0060bcddbf910a6" kindref="member">future_status</ref></type>
        <definition>future_status futures::wait_for_all_for</definition>
        <argsstring>(std::chrono::duration&lt; Rep, Period &gt; const &amp;timeout_duration, Fs &amp;&amp;...fs)</argsstring>
        <name>wait_for_all_for</name>
        <qualifiedname>futures::wait_for_all_for</qualifiedname>
        <param>
          <type>std::chrono::duration&lt; Rep, Period &gt; const &amp;</type>
          <declname>timeout_duration</declname>
        </param>
        <param>
          <type>Fs &amp;&amp;...</type>
          <declname>fs</declname>
        </param>
        <briefdescription>
<para>Wait for a sequence of futures to be ready. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Fs</parametername>
</parameternamelist>
<parameterdescription>
<para>Range of futures </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rep</parametername>
</parameternamelist>
<parameterdescription>
<para>Duration Rep </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Period</parametername>
</parameternamelist>
<parameterdescription>
<para>Duration Period </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>timeout_duration</parametername>
</parameternamelist>
<parameterdescription>
<para>Time to wait for </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fs</parametername>
</parameternamelist>
<parameterdescription>
<para>Future objects</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>future_status::ready</computeroutput> if all futures got ready. <computeroutput>future_status::timeout</computeroutput> otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/wait_for_all.hpp" line="236" column="5" declfile="futures/wait_for_all.hpp" declline="236" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__waiting_1gabe33547dffed01e98f0fbb5e6b250e5c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Tuple</type>
          </param>
          <param>
            <type>class Rep</type>
          </param>
          <param>
            <type>class Period</type>
          </param>
        </templateparamlist>
        <type>::value <ref refid="group__future-types_1ga2d9145fe40c699d6f0060bcddbf910a6" kindref="member">future_status</ref></type>
        <definition>::value future_status futures::wait_for_all_for</definition>
        <argsstring>(std::chrono::duration&lt; Rep, Period &gt; const &amp;timeout_duration, Tuple &amp;&amp;t)</argsstring>
        <name>wait_for_all_for</name>
        <qualifiedname>futures::wait_for_all_for</qualifiedname>
        <param>
          <type>std::chrono::duration&lt; Rep, Period &gt; const &amp;</type>
          <declname>timeout_duration</declname>
        </param>
        <param>
          <type>Tuple &amp;&amp;</type>
          <declname>t</declname>
        </param>
    <requiresclause>detail::mp_similar&lt;std::tuple&lt;&gt;, std::decay_t&lt;Tuple&gt;&gt;    </requiresclause>
        <briefdescription>
<para>Wait for a sequence of futures to be ready. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Tuple of futures </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rep</parametername>
</parameternamelist>
<parameterdescription>
<para>Duration Rep </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Period</parametername>
</parameternamelist>
<parameterdescription>
<para>Duration Period </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>timeout_duration</parametername>
</parameternamelist>
<parameterdescription>
<para>Time to wait for </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>Tuple of futures</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>future_status::ready</computeroutput> if all futures got ready. <computeroutput>future_status::timeout</computeroutput> otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/wait_for_all.hpp" line="266" column="5" declfile="futures/wait_for_all.hpp" declline="266" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__waiting_1gab87515245b042239085fb0c231dbf49d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>std::input_iterator</type>
            <declname>Iterator</declname>
            <defname>Iterator</defname>
          </param>
          <param>
            <type>class Clock</type>
          </param>
          <param>
            <type>class Duration</type>
          </param>
        </templateparamlist>
        <type><ref refid="group__future-types_1ga2d9145fe40c699d6f0060bcddbf910a6" kindref="member">future_status</ref></type>
        <definition>future_status futures::wait_for_all_until</definition>
        <argsstring>(std::chrono::time_point&lt; Clock, Duration &gt; const &amp;timeout_time, Iterator first, Iterator last)</argsstring>
        <name>wait_for_all_until</name>
        <qualifiedname>futures::wait_for_all_until</qualifiedname>
        <param>
          <type>std::chrono::time_point&lt; Clock, Duration &gt; const &amp;</type>
          <declname>timeout_time</declname>
        </param>
        <param>
          <type>Iterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>Iterator</type>
          <declname>last</declname>
        </param>
    <requiresclause>future_like&lt;std::iter_value_t&lt;Iterator&gt;&gt;    </requiresclause>
        <briefdescription>
<para>Wait for a sequence of futures to be ready. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Iterator</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator type in a range of futures </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Clock</parametername>
</parameternamelist>
<parameterdescription>
<para>Time point clock </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Duration</parametername>
</parameternamelist>
<parameterdescription>
<para>Time point duration </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>timeout_time</parametername>
</parameternamelist>
<parameterdescription>
<para>Limit time point </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator to the first element in the range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator to one past the last element in the range</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>future_status::ready</computeroutput> if all futures got ready. <computeroutput>future_status::timeout</computeroutput> otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/wait_for_all.hpp" line="293" column="5" declfile="futures/wait_for_all.hpp" declline="293" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__waiting_1gaec7ba0721287ed2d804fefcf60aeb043" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>std::ranges::range</type>
            <declname>Range</declname>
            <defname>Range</defname>
          </param>
          <param>
            <type>class Clock</type>
          </param>
          <param>
            <type>class Duration</type>
          </param>
        </templateparamlist>
        <type><ref refid="group__future-types_1ga2d9145fe40c699d6f0060bcddbf910a6" kindref="member">future_status</ref></type>
        <definition>future_status futures::wait_for_all_until</definition>
        <argsstring>(std::chrono::time_point&lt; Clock, Duration &gt; const &amp;timeout_time, Range &amp;&amp;r)</argsstring>
        <name>wait_for_all_until</name>
        <qualifiedname>futures::wait_for_all_until</qualifiedname>
        <param>
          <type>std::chrono::time_point&lt; Clock, Duration &gt; const &amp;</type>
          <declname>timeout_time</declname>
        </param>
        <param>
          <type>Range &amp;&amp;</type>
          <declname>r</declname>
        </param>
    <requiresclause>future_like&lt;range_value_t&lt;Range&gt;&gt;    </requiresclause>
        <briefdescription>
<para>Wait for a sequence of futures to be ready. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Range</parametername>
</parameternamelist>
<parameterdescription>
<para>Range of futures </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Clock</parametername>
</parameternamelist>
<parameterdescription>
<para>Time point clock </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Duration</parametername>
</parameternamelist>
<parameterdescription>
<para>Time point duration </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>timeout_time</parametername>
</parameternamelist>
<parameterdescription>
<para>Limit time point </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>r</parametername>
</parameternamelist>
<parameterdescription>
<para>Range of futures</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>future_status::ready</computeroutput> if all futures got ready. <computeroutput>future_status::timeout</computeroutput> otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/wait_for_all.hpp" line="323" column="5" bodyfile="futures/wait_for_all.hpp" bodystart="323" bodyend="328"/>
      </memberdef>
      <memberdef kind="function" id="group__waiting_1ga5176c9911068fd8dec7347b45b99ed64" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>future_like...</type>
            <declname>Fs</declname>
            <defname>Fs</defname>
          </param>
          <param>
            <type>class Clock</type>
          </param>
          <param>
            <type>class Duration</type>
          </param>
        </templateparamlist>
        <type><ref refid="group__future-types_1ga2d9145fe40c699d6f0060bcddbf910a6" kindref="member">future_status</ref></type>
        <definition>future_status futures::wait_for_all_until</definition>
        <argsstring>(std::chrono::time_point&lt; Clock, Duration &gt; const &amp;timeout_time, Fs &amp;&amp;...fs)</argsstring>
        <name>wait_for_all_until</name>
        <qualifiedname>futures::wait_for_all_until</qualifiedname>
        <param>
          <type>std::chrono::time_point&lt; Clock, Duration &gt; const &amp;</type>
          <declname>timeout_time</declname>
        </param>
        <param>
          <type>Fs &amp;&amp;...</type>
          <declname>fs</declname>
        </param>
        <briefdescription>
<para>Wait for a sequence of futures to be ready. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Fs</parametername>
</parameternamelist>
<parameterdescription>
<para>Future objects </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Clock</parametername>
</parameternamelist>
<parameterdescription>
<para>Time point clock </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Duration</parametername>
</parameternamelist>
<parameterdescription>
<para>Time point duration </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>timeout_time</parametername>
</parameternamelist>
<parameterdescription>
<para>Limit time point </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fs</parametername>
</parameternamelist>
<parameterdescription>
<para>Future objects</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>future_status::ready</computeroutput> if all futures got ready. <computeroutput>future_status::timeout</computeroutput> otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/wait_for_all.hpp" line="354" column="5" declfile="futures/wait_for_all.hpp" declline="354" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__waiting_1ga1e43cb93d4aca81d2313dc2ce032ec91" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Tuple</type>
          </param>
          <param>
            <type>class Clock</type>
          </param>
          <param>
            <type>class Duration</type>
          </param>
        </templateparamlist>
        <type>::value <ref refid="group__future-types_1ga2d9145fe40c699d6f0060bcddbf910a6" kindref="member">future_status</ref></type>
        <definition>::value future_status futures::wait_for_all_until</definition>
        <argsstring>(std::chrono::time_point&lt; Clock, Duration &gt; const &amp;timeout_time, Tuple &amp;&amp;t)</argsstring>
        <name>wait_for_all_until</name>
        <qualifiedname>futures::wait_for_all_until</qualifiedname>
        <param>
          <type>std::chrono::time_point&lt; Clock, Duration &gt; const &amp;</type>
          <declname>timeout_time</declname>
        </param>
        <param>
          <type>Tuple &amp;&amp;</type>
          <declname>t</declname>
        </param>
    <requiresclause>detail::mp_similar&lt;std::tuple&lt;&gt;, std::decay_t&lt;Tuple&gt;&gt;    </requiresclause>
        <briefdescription>
<para>Wait for a sequence of futures to be ready. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Tuple of futures </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Clock</parametername>
</parameternamelist>
<parameterdescription>
<para>Time point clock </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Duration</parametername>
</parameternamelist>
<parameterdescription>
<para>Time point duration </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>timeout_time</parametername>
</parameternamelist>
<parameterdescription>
<para>Limit time point </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>Tuple of futures</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>future_status::ready</computeroutput> if all futures got ready. <computeroutput>future_status::timeout</computeroutput> otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/wait_for_all.hpp" line="383" column="5" declfile="futures/wait_for_all.hpp" declline="383" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__waiting_1ga7fa10c7413d3b02bcf65e63ead2185c1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>std::input_iterator</type>
            <declname>Iterator</declname>
            <defname>Iterator</defname>
          </param>
        </templateparamlist>
        <type>Iterator</type>
        <definition>Iterator futures::wait_for_any</definition>
        <argsstring>(Iterator first, Iterator last)</argsstring>
        <name>wait_for_any</name>
        <qualifiedname>futures::wait_for_any</qualifiedname>
        <param>
          <type>Iterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>Iterator</type>
          <declname>last</declname>
        </param>
    <requiresclause>future_like&lt;iter_value_t&lt;Iterator&gt;&gt;    </requiresclause>
        <briefdescription>
<para>Wait for any future in a sequence to be ready. </para>
        </briefdescription>
        <detaileddescription>
<para>This function waits for any future in the range [<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) to be ready.</para>
<para>Unlike <ref refid="group__waiting_1ga059ba1404ba968cb2cb108a76f9cffa8" kindref="member">wait_for_all</ref>, this function requires special data structures to allow that to happen without blocking.</para>
<para>For disjunctions, we have few options:<itemizedlist>
<listitem><para>If the input futures support external notifiers:<itemizedlist>
<listitem><para>Attach continuations to notify when a task is over</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para>If the input futures do not have lazy continuations:<itemizedlist>
<listitem><para>Polling in a busy loop until one of the futures is ready</para>
</listitem><listitem><para>Polling with exponential backoffs until one of the futures is ready</para>
</listitem><listitem><para>Launching n continuation tasks that set a promise when one of the futures is ready</para>
</listitem><listitem><para>Hybrids, usually polling for short tasks and launching threads for other tasks</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para>If the input futures are mixed in regards to lazy continuations:<itemizedlist>
<listitem><para>Mix the strategies above, depending on each input future</para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para>
<para>If the thresholds for these strategies are reasonable, this should be efficient for futures with or without lazy continuations.</para>
<para><simplesect kind="note"><para>This function is adapted from <computeroutput>boost::wait_for_any</computeroutput></para>
</simplesect>
<simplesect kind="see"><para><ulink url="https://www.boost.org/doc/libs/1_78_0/doc/html/thread/synchronization.html#thread.synchronization.futures.reference.wait_for_any">boost.thread wait_for_any</ulink></para>
</simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Iterator</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator type in a range of futures </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator to the first element in the range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator to one past the last element in the range </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Iterator to the first future that got ready </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/wait_for_any.hpp" line="81" column="5" declfile="futures/wait_for_any.hpp" declline="81" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__waiting_1ga5a34d89268642da91a61c25184b47095" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>std::ranges::range</type>
            <declname>Range</declname>
            <defname>Range</defname>
          </param>
        </templateparamlist>
        <type><ref refid="group__traits_1ga25b9349b8a29ca3bea4913f8b704e515" kindref="member">iterator_t</ref>&lt; Range &gt;</type>
        <definition>iterator_t&lt; Range &gt; futures::wait_for_any</definition>
        <argsstring>(Range &amp;&amp;r)</argsstring>
        <name>wait_for_any</name>
        <qualifiedname>futures::wait_for_any</qualifiedname>
        <param>
          <type>Range &amp;&amp;</type>
          <declname>r</declname>
        </param>
    <requiresclause>future_like&lt;range_value_t&lt;Range&gt;&gt;    </requiresclause>
        <briefdescription>
<para>Wait for any future in a sequence to be ready. </para>
        </briefdescription>
        <detaileddescription>
<para>This function waits for any future in the range <computeroutput>r</computeroutput> to be ready. This function requires special data structures to allow that to happen without blocking.</para>
<para><simplesect kind="note"><para>This function is adapted from <computeroutput>boost::wait_for_any</computeroutput></para>
</simplesect>
<simplesect kind="see"><para><ulink url="https://www.boost.org/doc/libs/1_78_0/doc/html/thread/synchronization.html#thread.synchronization.futures.reference.wait_for_any">boost.thread wait_for_any</ulink></para>
</simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Iterator</parametername>
</parameternamelist>
<parameterdescription>
<para>A range of futures type </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>r</parametername>
</parameternamelist>
<parameterdescription>
<para>Range of futures </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Iterator to the first future that got ready </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/wait_for_any.hpp" line="111" column="5" bodyfile="futures/wait_for_any.hpp" bodystart="111" bodyend="113"/>
      </memberdef>
      <memberdef kind="function" id="group__waiting_1ga7ad63bcada8c89257d6338a0f40c6622" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>future_like...</type>
            <declname>Fs</declname>
            <defname>Fs</defname>
          </param>
        </templateparamlist>
        <type>std::size_t</type>
        <definition>std::size_t futures::wait_for_any</definition>
        <argsstring>(Fs &amp;&amp;...fs)</argsstring>
        <name>wait_for_any</name>
        <qualifiedname>futures::wait_for_any</qualifiedname>
        <param>
          <type>Fs &amp;&amp;...</type>
          <declname>fs</declname>
        </param>
        <briefdescription>
<para>Wait for any future in a sequence to be ready. </para>
        </briefdescription>
        <detaileddescription>
<para>This function waits for all specified futures <computeroutput>fs</computeroutput>... to be ready.</para>
<para><simplesect kind="note"><para>This function is adapted from <computeroutput>boost::wait_for_any</computeroutput></para>
</simplesect>
<simplesect kind="see"><para><ulink url="https://www.boost.org/doc/libs/1_78_0/doc/html/thread/synchronization.html#thread.synchronization.futures.reference.wait_for_any">boost.thread wait_for_any</ulink></para>
</simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Fs</parametername>
</parameternamelist>
<parameterdescription>
<para>A list of future types </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fs</parametername>
</parameternamelist>
<parameterdescription>
<para>A list of future objects </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Index of the first future that got ready </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/wait_for_any.hpp" line="140" column="5" declfile="futures/wait_for_any.hpp" declline="140" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__waiting_1ga9e77d6e17363998b5efbe74b4d0b2acb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Tuple</type>
          </param>
        </templateparamlist>
        <type>::value std::size_t</type>
        <definition>::value std::size_t futures::wait_for_any</definition>
        <argsstring>(Tuple &amp;&amp;t)</argsstring>
        <name>wait_for_any</name>
        <qualifiedname>futures::wait_for_any</qualifiedname>
        <param>
          <type>Tuple &amp;&amp;</type>
          <declname>t</declname>
        </param>
    <requiresclause>detail::mp_similar&lt;std::tuple&lt;&gt;, std::decay_t&lt;Tuple&gt;&gt;    </requiresclause>
        <briefdescription>
<para>Wait for any future in a tuple to be ready. </para>
        </briefdescription>
        <detaileddescription>
<para>This function waits for all specified futures <computeroutput>fs</computeroutput>... to be ready.</para>
<para><simplesect kind="note"><para>This function is adapted from <computeroutput>boost::wait_for_any</computeroutput></para>
</simplesect>
<simplesect kind="see"><para><ulink url="https://www.boost.org/doc/libs/1_78_0/doc/html/thread/synchronization.html#thread.synchronization.futures.reference.wait_for_any">boost.thread wait_for_any</ulink></para>
</simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Fs</parametername>
</parameternamelist>
<parameterdescription>
<para>A list of future types</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>A list of future objects</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Index of the first future that got ready </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/wait_for_any.hpp" line="170" column="5" declfile="futures/wait_for_any.hpp" declline="170" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__waiting_1gad32e2da4457116249c758eed1550e3ab" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>std::input_iterator</type>
            <declname>Iterator</declname>
            <defname>Iterator</defname>
          </param>
          <param>
            <type>class Rep</type>
          </param>
          <param>
            <type>class Period</type>
          </param>
        </templateparamlist>
        <type>Iterator</type>
        <definition>Iterator futures::wait_for_any_for</definition>
        <argsstring>(std::chrono::duration&lt; Rep, Period &gt; const &amp;timeout_duration, Iterator first, Iterator last)</argsstring>
        <name>wait_for_any_for</name>
        <qualifiedname>futures::wait_for_any_for</qualifiedname>
        <param>
          <type>std::chrono::duration&lt; Rep, Period &gt; const &amp;</type>
          <declname>timeout_duration</declname>
        </param>
        <param>
          <type>Iterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>Iterator</type>
          <declname>last</declname>
        </param>
    <requiresclause>future_like&lt;iter_value_t&lt;Iterator&gt;&gt;    </requiresclause>
        <briefdescription>
<para>Wait for any future in a sequence to be ready. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Iterator</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator type in a range of futures </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rep</parametername>
</parameternamelist>
<parameterdescription>
<para>Duration Rep </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Period</parametername>
</parameternamelist>
<parameterdescription>
<para>Duration Period </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>timeout_duration</parametername>
</parameternamelist>
<parameterdescription>
<para>Time to wait for </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator to the first element in the range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator to one past the last element in the range</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Iterator to the future which got ready </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/wait_for_any.hpp" line="194" column="5" declfile="futures/wait_for_any.hpp" declline="194" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__waiting_1ga916e8c489e9b283a63304287b9d86a8e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>std::ranges::range</type>
            <declname>Range</declname>
            <defname>Range</defname>
          </param>
          <param>
            <type>class Rep</type>
          </param>
          <param>
            <type>class Period</type>
          </param>
        </templateparamlist>
        <type><ref refid="group__traits_1ga25b9349b8a29ca3bea4913f8b704e515" kindref="member">iterator_t</ref>&lt; Range &gt;</type>
        <definition>iterator_t&lt; Range &gt; futures::wait_for_any_for</definition>
        <argsstring>(std::chrono::duration&lt; Rep, Period &gt; const &amp;timeout_duration, Range &amp;&amp;r)</argsstring>
        <name>wait_for_any_for</name>
        <qualifiedname>futures::wait_for_any_for</qualifiedname>
        <param>
          <type>std::chrono::duration&lt; Rep, Period &gt; const &amp;</type>
          <declname>timeout_duration</declname>
        </param>
        <param>
          <type>Range &amp;&amp;</type>
          <declname>r</declname>
        </param>
    <requiresclause>future_like&lt;std::ranges::range_value_t&lt;Range&gt;&gt;    </requiresclause>
        <briefdescription>
<para>Wait for any future in a sequence to be ready. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Range</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator type in a range of futures </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rep</parametername>
</parameternamelist>
<parameterdescription>
<para>Duration Rep </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Period</parametername>
</parameternamelist>
<parameterdescription>
<para>Duration Period </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>timeout_duration</parametername>
</parameternamelist>
<parameterdescription>
<para>Time to wait for </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>r</parametername>
</parameternamelist>
<parameterdescription>
<para>Range of futures</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Iterator to the future which got ready </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/wait_for_any.hpp" line="223" column="5" bodyfile="futures/wait_for_any.hpp" bodystart="223" bodyend="227"/>
      </memberdef>
      <memberdef kind="function" id="group__waiting_1gac858955f3202d94606e73574f302f9c9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>future_like...</type>
            <declname>Fs</declname>
            <defname>Fs</defname>
          </param>
          <param>
            <type>class Rep</type>
          </param>
          <param>
            <type>class Period</type>
          </param>
        </templateparamlist>
        <type>std::size_t</type>
        <definition>std::size_t futures::wait_for_any_for</definition>
        <argsstring>(std::chrono::duration&lt; Rep, Period &gt; const &amp;timeout_duration, Fs &amp;&amp;...fs)</argsstring>
        <name>wait_for_any_for</name>
        <qualifiedname>futures::wait_for_any_for</qualifiedname>
        <param>
          <type>std::chrono::duration&lt; Rep, Period &gt; const &amp;</type>
          <declname>timeout_duration</declname>
        </param>
        <param>
          <type>Fs &amp;&amp;...</type>
          <declname>fs</declname>
        </param>
        <briefdescription>
<para>Wait for any future in a sequence to be ready. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Fs</parametername>
</parameternamelist>
<parameterdescription>
<para>Future types </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rep</parametername>
</parameternamelist>
<parameterdescription>
<para>Duration Rep </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Period</parametername>
</parameternamelist>
<parameterdescription>
<para>Duration Period </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>timeout_duration</parametername>
</parameternamelist>
<parameterdescription>
<para>Time to wait for </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fs</parametername>
</parameternamelist>
<parameterdescription>
<para>Future objects</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Index of the future which got ready </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/wait_for_any.hpp" line="253" column="5" declfile="futures/wait_for_any.hpp" declline="253" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__waiting_1gaa71e8ffc7c5260316fea850335e29860" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Tuple</type>
          </param>
          <param>
            <type>class Rep</type>
          </param>
          <param>
            <type>class Period</type>
          </param>
        </templateparamlist>
        <type>::value std::size_t</type>
        <definition>::value std::size_t futures::wait_for_any_for</definition>
        <argsstring>(std::chrono::duration&lt; Rep, Period &gt; const &amp;timeout_duration, Tuple &amp;&amp;t)</argsstring>
        <name>wait_for_any_for</name>
        <qualifiedname>futures::wait_for_any_for</qualifiedname>
        <param>
          <type>std::chrono::duration&lt; Rep, Period &gt; const &amp;</type>
          <declname>timeout_duration</declname>
        </param>
        <param>
          <type>Tuple &amp;&amp;</type>
          <declname>t</declname>
        </param>
    <requiresclause>detail::mp_similar&lt;std::tuple&lt;&gt;, std::decay_t&lt;Tuple&gt;&gt;    </requiresclause>
        <briefdescription>
<para>Wait for any future in a sequence to be ready. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Tuple of futures </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rep</parametername>
</parameternamelist>
<parameterdescription>
<para>Duration Rep </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Period</parametername>
</parameternamelist>
<parameterdescription>
<para>Duration Period </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>timeout_duration</parametername>
</parameternamelist>
<parameterdescription>
<para>Time to wait for </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>tuple of futures</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Index of the future which got ready </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/wait_for_any.hpp" line="281" column="5" declfile="futures/wait_for_any.hpp" declline="281" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__waiting_1ga55f81bf19839326a15d9daad7667cc2a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>std::input_iterator</type>
            <declname>Iterator</declname>
            <defname>Iterator</defname>
          </param>
          <param>
            <type>class Clock</type>
          </param>
          <param>
            <type>class Duration</type>
          </param>
        </templateparamlist>
        <type>Iterator</type>
        <definition>Iterator futures::wait_for_any_until</definition>
        <argsstring>(std::chrono::time_point&lt; Clock, Duration &gt; const &amp;timeout_time, Iterator first, Iterator last)</argsstring>
        <name>wait_for_any_until</name>
        <qualifiedname>futures::wait_for_any_until</qualifiedname>
        <param>
          <type>std::chrono::time_point&lt; Clock, Duration &gt; const &amp;</type>
          <declname>timeout_time</declname>
        </param>
        <param>
          <type>Iterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>Iterator</type>
          <declname>last</declname>
        </param>
    <requiresclause>future_like&lt;iter_value_t&lt;Iterator&gt;&gt;    </requiresclause>
        <briefdescription>
<para>Wait for any future in a sequence to be ready. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Iterator</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator type in a range of futures </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Clock</parametername>
</parameternamelist>
<parameterdescription>
<para>Time point clock </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Duration</parametername>
</parameternamelist>
<parameterdescription>
<para>Time point duration </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>timeout_time</parametername>
</parameternamelist>
<parameterdescription>
<para>Limit time point </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator to the first element in the range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator to one past the last element in the range</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Iterator to the future which got ready </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/wait_for_any.hpp" line="307" column="5" declfile="futures/wait_for_any.hpp" declline="307" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__waiting_1ga498289356066c74ee09b692586f55b8e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>std::ranges::range</type>
            <declname>Range</declname>
            <defname>Range</defname>
          </param>
          <param>
            <type>class Clock</type>
          </param>
          <param>
            <type>class Duration</type>
          </param>
        </templateparamlist>
        <type><ref refid="group__traits_1ga25b9349b8a29ca3bea4913f8b704e515" kindref="member">iterator_t</ref>&lt; Range &gt;</type>
        <definition>iterator_t&lt; Range &gt; futures::wait_for_any_until</definition>
        <argsstring>(std::chrono::time_point&lt; Clock, Duration &gt; const &amp;timeout_time, Range &amp;&amp;r)</argsstring>
        <name>wait_for_any_until</name>
        <qualifiedname>futures::wait_for_any_until</qualifiedname>
        <param>
          <type>std::chrono::time_point&lt; Clock, Duration &gt; const &amp;</type>
          <declname>timeout_time</declname>
        </param>
        <param>
          <type>Range &amp;&amp;</type>
          <declname>r</declname>
        </param>
    <requiresclause>future_like&lt;range_value_t&lt;Range&gt;&gt;    </requiresclause>
        <briefdescription>
<para>Wait for any future in a sequence to be ready. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Range</parametername>
</parameternamelist>
<parameterdescription>
<para>Range of futures </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Clock</parametername>
</parameternamelist>
<parameterdescription>
<para>Time point clock </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Duration</parametername>
</parameternamelist>
<parameterdescription>
<para>Time point duration </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>timeout_time</parametername>
</parameternamelist>
<parameterdescription>
<para>Limit time point </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>r</parametername>
</parameternamelist>
<parameterdescription>
<para>Range of futures</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Iterator to the future which got ready </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/wait_for_any.hpp" line="336" column="5" bodyfile="futures/wait_for_any.hpp" bodystart="336" bodyend="340"/>
      </memberdef>
      <memberdef kind="function" id="group__waiting_1ga109330c8b2744f4d74464a2533b98556" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>future_like...</type>
            <declname>Fs</declname>
            <defname>Fs</defname>
          </param>
          <param>
            <type>class Clock</type>
          </param>
          <param>
            <type>class Duration</type>
          </param>
        </templateparamlist>
        <type>std::size_t</type>
        <definition>std::size_t futures::wait_for_any_until</definition>
        <argsstring>(std::chrono::time_point&lt; Clock, Duration &gt; const &amp;timeout_time, Fs &amp;&amp;...fs)</argsstring>
        <name>wait_for_any_until</name>
        <qualifiedname>futures::wait_for_any_until</qualifiedname>
        <param>
          <type>std::chrono::time_point&lt; Clock, Duration &gt; const &amp;</type>
          <declname>timeout_time</declname>
        </param>
        <param>
          <type>Fs &amp;&amp;...</type>
          <declname>fs</declname>
        </param>
        <briefdescription>
<para>Wait for any future in a sequence to be ready. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Fs</parametername>
</parameternamelist>
<parameterdescription>
<para>Future types </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Clock</parametername>
</parameternamelist>
<parameterdescription>
<para>Time point clock </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Duration</parametername>
</parameternamelist>
<parameterdescription>
<para>Time point duration </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>timeout_time</parametername>
</parameternamelist>
<parameterdescription>
<para>Limit time point </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fs</parametername>
</parameternamelist>
<parameterdescription>
<para>Future objects</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Index of the future which got ready </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/wait_for_any.hpp" line="366" column="5" declfile="futures/wait_for_any.hpp" declline="366" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__waiting_1gab0146fa5deaf49968c0aa421ebca990b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Tuple</type>
          </param>
          <param>
            <type>class Clock</type>
          </param>
          <param>
            <type>class Duration</type>
          </param>
        </templateparamlist>
        <type>::value std::size_t</type>
        <definition>::value std::size_t futures::wait_for_any_until</definition>
        <argsstring>(std::chrono::time_point&lt; Clock, Duration &gt; const &amp;timeout_time, Tuple &amp;&amp;t)</argsstring>
        <name>wait_for_any_until</name>
        <qualifiedname>futures::wait_for_any_until</qualifiedname>
        <param>
          <type>std::chrono::time_point&lt; Clock, Duration &gt; const &amp;</type>
          <declname>timeout_time</declname>
        </param>
        <param>
          <type>Tuple &amp;&amp;</type>
          <declname>t</declname>
        </param>
    <requiresclause>detail::mp_similar&lt;std::tuple&lt;&gt;, std::decay_t&lt;Tuple&gt;&gt;    </requiresclause>
        <briefdescription>
<para>Wait for any future in a sequence to be ready. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Tuple of future types </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Clock</parametername>
</parameternamelist>
<parameterdescription>
<para>Time point clock </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Duration</parametername>
</parameternamelist>
<parameterdescription>
<para>Time point duration </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>timeout_time</parametername>
</parameternamelist>
<parameterdescription>
<para>Limit time point </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>Tuple of future objects</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Index of the future which got ready </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="futures/wait_for_any.hpp" line="394" column="5" declfile="futures/wait_for_any.hpp" declline="394" declcolumn="5"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Main library namespace. </para>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="futures/future.hpp" line="101" column="1"/>
  </compounddef>
</doxygen>
